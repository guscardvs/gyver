{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gyver","text":"<p>Simple toolbox for python development to skip code boilerplate.</p> <p>Documentation</p> <p>Source Code</p> <p>This documentation refers to version 2.6</p>"},{"location":"#authors","title":"Authors","text":"<p>@guscardvs</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> </ul>"},{"location":"#required","title":"Required","text":"<ul> <li>OrJSON for json parsing.</li> <li>Pydantic 1.x for data handling. (Support for v2 is under development)</li> <li>Typing Extensions for compatibility.</li> <li>Cryptography to handle encryption.</li> </ul>"},{"location":"#optional","title":"Optional","text":"<p>To use the database parts:</p> <ul> <li> <p>Mysql/MariaDB: AioMySQL, PyMySQL (use db-mysql or db-mariadb extras)</p> </li> <li> <p>Postgres: AsyncPG, Psycopg2</p> </li> <li> <p>SQLite: aiosqlite</p> </li> <li> <p>Redis: redis</p> </li> <li> <p>And SQLAlchemy</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"pip install gyverDone!"},{"location":"#roadmap","title":"Roadmap","text":"<p>Move database related code to a separate library and add support for Pydantic V2</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"reference/config/","title":"Config","text":""},{"location":"reference/config/#gyver.config.MISSING","title":"<code>MISSING</code>","text":""},{"location":"reference/config/#gyver.config.Config","title":"<code>Config</code>","text":"<p>Configuration settings for working with environment variables.</p>"},{"location":"reference/config/#config.config.Config.__call__","title":"<code>__call__(name, cast=_default_cast, default=MISSING)</code>","text":"<p>Get the value of the specified environment variable, optionally casting it using the callable syntax.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <code>cast</code> <code>Union[Callable[[Any], T], type[T]]</code> <p>The casting function or type. Defaults to _default_cast.</p> <code>_default_cast</code> <code>default</code> <code>Union[T, type[MISSING]]</code> <p>The default value to return if the variable is not found. Defaults to MISSING.</p> <code>MISSING</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value of the environment variable, casted if necessary.</p> <p>Raises:</p> Type Description <code>MissingName</code> <p>If the environment variable is not found and no default value is provided.</p> <code>InvalidCast</code> <p>If casting the value is unsuccessful.</p>"},{"location":"reference/config/#config.config.Config.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the Config instance after construction.</p> <p>Reads values from the environment file and updates the internal mapping if necessary.</p>"},{"location":"reference/config/#config.config.Config.file_values","title":"<code>file_values()</code>","text":"<p>Lazy field for storing values read from the environment file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing values read from the environment file.</p>"},{"location":"reference/config/#config.config.Config.get","title":"<code>get(name, cast=_default_cast, default=MISSING)</code>","text":"<p>Get the value of the specified environment variable, optionally casting it.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <code>cast</code> <code>Callable</code> <p>The casting function. Defaults to _default_cast.</p> <code>_default_cast</code> <code>default</code> <code>Union[Any, type[MISSING]]</code> <p>The default value to return if the variable is not found. Defaults to MISSING.</p> <code>MISSING</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the environment variable, casted if necessary.</p> <p>Raises:</p> Type Description <code>MissingName</code> <p>If the environment variable is not found and no default value is provided.</p> <code>InvalidCast</code> <p>If casting the value is unsuccessful.</p>"},{"location":"reference/config/#gyver.config.EnvMapping","title":"<code>EnvMapping</code>","text":"<p>             Bases: <code>MutableMapping[str, str]</code></p> <p>A mutable mapping representing the environment variables.</p>"},{"location":"reference/config/#config.config.EnvMapping.__delitem__","title":"<code>__delitem__(name)</code>","text":"<p>Delete the specified environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the environment variable has already been read.</p>"},{"location":"reference/config/#config.config.EnvMapping.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Get the value of the specified environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The value of the environment variable.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the environment variable is not found.</p>"},{"location":"reference/config/#config.config.EnvMapping.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate through the environment variable names.</p> <p>Yields:</p> Name Type Description <code>str</code> <code>str</code> <p>The names of environment variables.</p>"},{"location":"reference/config/#config.config.EnvMapping.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of environment variables.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of environment variables.</p>"},{"location":"reference/config/#config.config.EnvMapping.__setitem__","title":"<code>__setitem__(name, value)</code>","text":"<p>Set the value of the specified environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the environment variable.</p> required <code>value</code> <code>str</code> <p>The new value for the environment variable.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the environment variable has already been read.</p>"},{"location":"reference/config/#gyver.config.Env","title":"<code>Env</code>","text":"<p>             Bases: <code>EnvTuple</code>, <code>Enum</code></p> <p>An enumeration representing different environment values with associated weights.</p> <p>Attributes:</p> Name Type Description <code>LOCAL</code> <code>Env</code> <p>The local environment.</p> <code>TEST</code> <code>Env</code> <p>The test environment.</p> <code>DEV</code> <code>Env</code> <p>The development environment.</p> <code>QA</code> <code>Env</code> <p>The quality assurance environment.</p> <code>PRD</code> <code>Env</code> <p>The production environment.</p>"},{"location":"reference/config/#config.enums.Env.val","title":"<code>val</code>  <code>property</code>","text":"<p>Get the environment value.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The environment value.</p>"},{"location":"reference/config/#config.enums.Env.value","title":"<code>value: EnvTuple</code>  <code>property</code>","text":"<p>Get the value associated with the environment.</p> <p>Returns:</p> Name Type Description <code>EnvTuple</code> <code>EnvTuple</code> <p>The value associated with the environment.</p>"},{"location":"reference/config/#config.enums.Env.weight","title":"<code>weight</code>  <code>property</code>","text":"<p>Get the weight associated with the environment.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The weight associated with the environment.</p>"},{"location":"reference/config/#config.enums.Env.new","title":"<code>new(val)</code>  <code>classmethod</code>","text":"<p>Create a new instance of the Env enum based on the given environment value.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>The environment value to create an instance for.</p> required <p>Returns:</p> Name Type Description <code>Env</code> <code>Self</code> <p>An instance of the Env enum based on the given value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided value is not a valid environment value.</p>"},{"location":"reference/config/#gyver.config.DotFile","title":"<code>DotFile</code>","text":"<p>Represents a configuration dotfile associated with a specific environment.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>Union[str, Path]</code> <p>The filename or path of the dotfile.</p> <code>env</code> <code>Env</code> <p>The environment associated with the dotfile.</p> <code>apply_to_lower</code> <code>bool</code> <p>Indicates whether the dotfile should be applied to lower-priority environments.</p>"},{"location":"reference/config/#config.envconfig.DotFile.is_higher","title":"<code>is_higher(env)</code>","text":"<p>Check if the dotfile's environment is higher or equal to the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Env</code> <p>The environment to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the dotfile's environment is higher or equal to the given environment, False otherwise.</p>"},{"location":"reference/config/#gyver.config.EnvConfig","title":"<code>EnvConfig</code>","text":"<p>             Bases: <code>Config</code></p> <p>Extended configuration class that supports environment-specific configurations.</p>"},{"location":"reference/config/#config.envconfig.EnvConfig.__init__","title":"<code>__init__(*dotfiles, env_var='CONFIG_ENV', mapping=default_mapping, ignore_default_rule=default_rule, env_cast=Env.new)</code>","text":"<p>Initialize the EnvConfig instance.</p> <p>Parameters:</p> Name Type Description Default <code>*dotfiles</code> <code>DotFile</code> <p>One or more DotFile instances representing configuration dotfiles.</p> <code>()</code> <code>env_var</code> <code>str</code> <p>The name of the environment variable to determine the current environment.</p> <code>'CONFIG_ENV'</code> <code>mapping</code> <code>EnvMapping</code> <p>An environment mapping to use for configuration values.</p> <code>default_mapping</code> <code>ignore_default_rule</code> <code>Callable[[Env], bool]</code> <p>A callable to determine whether to ignore default values.</p> <code>default_rule</code> <code>env_cast</code> <code>Callable[[str], Env]</code> <p>A callable to cast the environment name to an Env enum value.</p> <code>Env.new</code>"},{"location":"reference/config/#config.envconfig.EnvConfig.dotfile","title":"<code>dotfile()</code>","text":"<p>Get the applicable dotfile for the current environment.</p> <p>Returns:</p> Name Type Description <code>DotFile</code> <p>The applicable dotfile, or None if no matching dotfile is found.</p>"},{"location":"reference/config/#config.envconfig.EnvConfig.env","title":"<code>env()</code>","text":"<p>Get the current environment from the configuration.</p> <p>Returns:</p> Name Type Description <code>Env</code> <p>The current environment.</p>"},{"location":"reference/config/#config.envconfig.EnvConfig.get","title":"<code>get(name, cast=..., default=...)</code>","text":"<p>Get a configuration value, with the option to cast and provide a default value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration value.</p> required <code>cast</code> <code>Callable[..., Any]</code> <p>A callable to cast the value.</p> <code>...</code> <code>default</code> <code>Union[Any, type[MISSING]]</code> <p>The default value if the configuration is not found.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The configuration value.</p>"},{"location":"reference/config/#config.envconfig.EnvConfig.ignore_default","title":"<code>ignore_default()</code>","text":"<p>Determine whether to ignore default values based on the current environment.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if default values should be ignored, False otherwise.</p>"},{"location":"reference/config/#gyver.config.ConfigLike","title":"<code>ConfigLike</code>","text":"<p>             Bases: <code>Protocol</code></p>"},{"location":"reference/config/#gyver.config.AdapterConfigFactory","title":"<code>AdapterConfigFactory</code>","text":"<p>Factory for creating configuration instances based on model classes.</p>"},{"location":"reference/config/#gyver.config.adapter.factory.AdapterConfigFactory.get_strategy_class","title":"<code>get_strategy_class(config_class)</code>  <code>staticmethod</code>","text":"<p>Get the appropriate strategy class for resolving fields in the configuration class.</p> <p>Parameters:</p> Name Type Description Default <code>config_class</code> <code>type</code> <p>The configuration class to resolve.</p> required <p>Returns:</p> Type Description <code>type[FieldResolverStrategy]</code> <p>type[FieldResolverStrategy]: The strategy class for resolving fields.</p>"},{"location":"reference/config/#gyver.config.adapter.factory.AdapterConfigFactory.maker","title":"<code>maker(model_cls, __prefix__='', __sep__='__', *, presets=None, **defaults)</code>","text":"<p>Create a factory function for loading configuration instances.</p> <p>Parameters:</p> Name Type Description Default <code>model_cls</code> <code>type[T]</code> <p>The model class representing the configuration.</p> required <code>__prefix__</code> <code>str</code> <p>Optional prefix for configuration fields.</p> <code>''</code> <code>presets</code> <code>Optional[Mapping[str, Any]]</code> <p>Optional preset values for fields.</p> <code>None</code> <code>**defaults</code> <code>Any</code> <p>Default values for fields.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[], T]</code> <p>Callable[[], T]: The factory function for loading configuration instances.</p>"},{"location":"reference/config/#gyver.config.adapter.factory.AdapterConfigFactory.resolve_confignames","title":"<code>resolve_confignames(root)</code>  <code>classmethod</code>","text":"<p>Resolve the environment variable names required by marked config classes.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>The root directory of the project.</p> required <p>Returns:</p> Type Description <code>dict[type, tuple[Sequence[str], ...]]</code> <p>dict[type, tuple[Sequence[str], ...]]: A dictionary of config classes and their associated environment variable names.</p>"},{"location":"reference/config/#gyver.config.boolean_cast","title":"<code>boolean_cast(string)</code>","text":"<p>Converts a string to its boolean equivalent.</p> <p>1 and true (case-insensitive) are considered True, everything else is False.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to check if it represents a boolean value.</p> required <p>Returns:</p> Type Description <p>MaybeResult[P, bool]: A maybe result helper. If called normally, it returns an Optional[bool].</p> <p>If called with <code>.strict(string)</code>, it raises an error if <code>boolean_cast</code> returns None.</p> <p>If called with <code>.optional(string)</code>, it returns Optional[bool], suppressing exceptions caused by None values.</p>"},{"location":"reference/config/#gyver.config.joined_cast","title":"<code>joined_cast(cast)</code>","text":"<p>Creates a joined casting function for chaining casting operations.</p> <p>Parameters:</p> Name Type Description Default <code>cast</code> <code>Callable[[str], T]</code> <p>The casting function to apply.</p> required <p>Returns:</p> Type Description <code>_JoinedCast[str, T]</code> <p>_JoinedCast[str, T]: A <code>_JoinedCast</code> object that allows chaining casting operations.</p>"},{"location":"reference/config/#gyver.config.valid_path","title":"<code>valid_path(val)</code>","text":"<p>Converts a string to a Path object and checks if the path exists.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>The string representing a file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the path does not exist.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>A Path object representing the file path.</p>"},{"location":"reference/config/#gyver.config.with_rule","title":"<code>with_rule(rule)</code>","text":"<p>Applies a rule check on a value, raising an <code>InvalidEnv</code> exception if the rule is not satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Callable[[Any], bool]</code> <p>The rule function to apply.</p> required <p>Raises:</p> Type Description <code>InvalidEnv</code> <p>If the rule condition is not met.</p> <p>Returns:</p> Type Description <p>Callable[[T], T]: A caster function that applies the rule check.</p>"},{"location":"reference/config/#gyver.config.as_config","title":"<code>as_config(cls)</code>","text":"<p>Transform a class into a config class.</p> <p>This function applies the @define decorator from gyver.attrs and also marks the class as a config_class</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[T]</code> <p>The class to be transformed into a config class.</p> required <p>Returns:</p> Type Description <code>type[T]</code> <p>type[T]: The transformed class, marked as a config class.</p>"},{"location":"reference/config/#gyver.config.mark","title":"<code>mark(cls)</code>","text":"<p>Mark a given class as a config class. If the attribute config_class already exists, but is not the SENTINEL, it raises a TypeError indicating that the attribute has an unexpected value. It is used by the resolve_confignames to differentiate config classes</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[T]</code> <p>The class to be marked as a config class.</p> required <p>Returns:</p> Type Description <code>type[T]</code> <p>type[T]: The class, marked as a config class.</p>"},{"location":"reference/context/","title":"Context","text":""},{"location":"reference/context/#gyver.context.Adapter","title":"<code>Adapter</code>","text":"<p>             Bases: <code>typing.Protocol[T]</code></p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.Adapter.is_closed","title":"<code>is_closed(client)</code>","text":"<p>Returns whether the client state is closed or released.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.Adapter.new","title":"<code>new()</code>","text":"<p>Creates a new client.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.Adapter.release","title":"<code>release(client)</code>","text":"<p>Closes or releases the client.</p>"},{"location":"reference/context/#gyver.context.AsyncAdapter","title":"<code>AsyncAdapter</code>","text":"<p>             Bases: <code>typing.Protocol[T]</code></p> <p>Represents an Adapter to a Specific Service.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AsyncAdapter.is_closed","title":"<code>is_closed(client)</code>  <code>async</code>","text":"<p>Returns whether the client state is closed or released.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AsyncAdapter.new","title":"<code>new()</code>  <code>async</code>","text":"<p>Creates a new client.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AsyncAdapter.release","title":"<code>release(client)</code>  <code>async</code>","text":"<p>Closes or releases the client.</p>"},{"location":"reference/context/#gyver.context.AtomicAdapter","title":"<code>AtomicAdapter</code>","text":"<p>             Bases: <code>Adapter[T]</code>, <code>typing.Protocol[T]</code></p> <p>Represents an Adapter to a Specific Service that can perform atomic operations.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAdapter.begin","title":"<code>begin(client)</code>","text":"<p>Starts an atomic operation.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAdapter.commit","title":"<code>commit(client)</code>","text":"<p>Commits an atomic operation.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAdapter.in_atomic","title":"<code>in_atomic(client)</code>","text":"<p>Returns whether the client is currently in an atomic operation.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAdapter.rollback","title":"<code>rollback(client)</code>","text":"<p>Rolls back an atomic operation.</p>"},{"location":"reference/context/#gyver.context.AtomicAsyncAdapter","title":"<code>AtomicAsyncAdapter</code>","text":"<p>             Bases: <code>AsyncAdapter[T]</code>, <code>typing.Protocol[T]</code></p> <p>Represents an Adapter to a Specific Service that can perform atomic operations.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAsyncAdapter.begin","title":"<code>begin(client)</code>  <code>async</code>","text":"<p>Starts an atomic operation.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAsyncAdapter.commit","title":"<code>commit(client)</code>  <code>async</code>","text":"<p>Commits an atomic operation.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAsyncAdapter.in_atomic","title":"<code>in_atomic(client)</code>  <code>async</code>","text":"<p>Returns whether the client is currently in an atomic operation.</p>"},{"location":"reference/context/#gyver.context.interfaces.adapter.AtomicAsyncAdapter.rollback","title":"<code>rollback(client)</code>  <code>async</code>","text":"<p>Rolls back an atomic operation.</p>"},{"location":"reference/context/#gyver.context.Context","title":"<code>Context</code>","text":"<p>             Bases: <code>typing.Generic[T]</code></p>"},{"location":"reference/context/#gyver.context.context.Context.adapter","title":"<code>adapter: interfaces.Adapter[T]</code>  <code>property</code>","text":"<p>Returns the adapter that is being used by this context.</p>"},{"location":"reference/context/#gyver.context.context.Context.stack","title":"<code>stack: int</code>  <code>property</code>","text":"<p>Returns how many frames are using this context.</p>"},{"location":"reference/context/#gyver.context.context.Context.__enter__","title":"<code>__enter__()</code>","text":"<p>Acquires a new resource from the adapter and increases the stack count.</p>"},{"location":"reference/context/#gyver.context.context.Context.__exit__","title":"<code>__exit__(*_)</code>","text":"<p>Releases the current resource if the stack count is 1, and decreases the stack count.</p>"},{"location":"reference/context/#gyver.context.context.Context.__init__","title":"<code>__init__(adapter)</code>","text":"<p>Initialize a new Context.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>interfaces.Adapter[T]</code> <p>An adapter that will be used to acquire and release resources.</p> required"},{"location":"reference/context/#gyver.context.context.Context.acquire","title":"<code>acquire()</code>","text":"<p>Acquires a new resource from the adapter and increases the stack count.</p>"},{"location":"reference/context/#gyver.context.context.Context.begin","title":"<code>begin()</code>","text":"<p>A context manager that acquires and releases resources and returns it.</p>"},{"location":"reference/context/#gyver.context.context.Context.client","title":"<code>client()</code>","text":"<p>Returns the current resource being used by the context. Acquires a new resource if the current one is closed or doesn't exist.</p>"},{"location":"reference/context/#gyver.context.context.Context.is_active","title":"<code>is_active()</code>","text":"<p>Returns whether the context is currently in use.</p>"},{"location":"reference/context/#gyver.context.context.Context.open","title":"<code>open()</code>","text":"<p>A context manager that acquires and releases resources without returning it.</p>"},{"location":"reference/context/#gyver.context.context.Context.release","title":"<code>release()</code>","text":"<p>Releases the current resource if the stack count is 1, and decreases the stack count.</p>"},{"location":"reference/context/#gyver.context.AsyncContext","title":"<code>AsyncContext</code>","text":"<p>             Bases: <code>typing.Generic[T]</code></p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.adapter","title":"<code>adapter: interfaces.AsyncAdapter[T]</code>  <code>property</code>","text":"<p>Returns the adapter that is being used by this context.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.stack","title":"<code>stack: int</code>  <code>property</code>","text":"<p>Returns how many frames are using this context.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Acquires a new resource from the adapter and increases the stack count.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.__aexit__","title":"<code>__aexit__(*_)</code>  <code>async</code>","text":"<p>Releases the current resource if the stack count is 1, and decreases the stack count.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.__init__","title":"<code>__init__(adapter)</code>","text":"<p>Initialize a new AsyncContext.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>interfaces.AsyncAdapter[T]</code> <p>An async adapter that will be used to acquire and release resources.</p> required"},{"location":"reference/context/#gyver.context.context.AsyncContext.acquire","title":"<code>acquire()</code>  <code>async</code>","text":"<p>Acquires a new resource from the adapter and increases the stack count.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.begin","title":"<code>begin()</code>  <code>async</code>","text":"<p>An async context manager that acquires and releases resources and returns it.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.client","title":"<code>client()</code>  <code>async</code>","text":"<p>Returns the current resource being used by the context. Acquires a new resource if the current one is closed or doesn't exist.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.is_active","title":"<code>is_active()</code>","text":"<p>Returns whether the context is currently in use.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.open","title":"<code>open()</code>  <code>async</code>","text":"<p>An async context manager that acquires and releases resources without returning it.</p>"},{"location":"reference/context/#gyver.context.context.AsyncContext.release","title":"<code>release()</code>  <code>async</code>","text":"<p>Releases the current resource if the stack count is 1, and decreases the stack count.</p>"},{"location":"reference/context/#gyver.context.atomic","title":"<code>atomic(context, bound=True)</code>","text":"<p>Create an atomic context or a bound context based on the given context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Union[Context[T], AsyncContext[T]]</code> <p>The base context to be wrapped.</p> required <code>bound</code> <code>bool</code> <p>Whether to create a bound context. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[Context[T], AsyncContext[T]]</code> <p>Union[Context[T], AsyncContext[T]]: The created atomic or bound context.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provider received is not compliant with the atomic adapter interface.</p>"},{"location":"reference/database/","title":"Database","text":""},{"location":"reference/database/#gyver.database.Driver","title":"<code>Driver</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Enum representing database drivers.</p> <p>Attributes:</p> Name Type Description <code>MYSQL</code> <code>str</code> <p>MySQL driver.</p> <code>POSTGRES</code> <code>str</code> <p>PostgreSQL driver.</p> <code>SQLITE</code> <code>str</code> <p>SQLite driver.</p> <code>MARIADB</code> <code>str</code> <p>MariaDB driver.</p> <code>CUSTOM</code> <code>str</code> <p>Custom driver.</p>"},{"location":"reference/database/#gyver.database.DatabaseAdapter","title":"<code>DatabaseAdapter</code>","text":""},{"location":"reference/database/#gyver.database.Dialect","title":"<code>Dialect</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Protocol representing a database dialect.</p> <p>Attributes:</p> Name Type Description <code>default_port</code> <code>int</code> <p>The default port for the database dialect.</p> <code>driver</code> <code>Driver</code> <p>The driver associated with the dialect.</p> <code>dialect_name</code> <code>str</code> <p>The name of the database dialect.</p> <code>async_driver</code> <code>str</code> <p>The asynchronous driver name.</p> <code>sync_driver</code> <code>str</code> <p>The synchronous driver name.</p> <code>only_host</code> <code>bool</code> <p>Indicates if the dialect supports only host connections.</p>"},{"location":"reference/database/#gyver.database.DialectInfo","title":"<code>DialectInfo</code>","text":"<p>Represents information about a database dialect.</p> <p>Attributes:</p> Name Type Description <code>default_port</code> <code>int</code> <p>The default port for the database dialect.</p> <code>driver</code> <code>Driver</code> <p>The driver associated with the dialect.</p> <code>dialect_name</code> <code>str</code> <p>The name of the database dialect.</p> <code>async_driver</code> <code>str</code> <p>The asynchronous driver name.</p> <code>sync_driver</code> <code>str</code> <p>The synchronous driver name.</p> <code>only_host</code> <code>bool</code> <p>Indicates if the dialect supports only host connections.</p>"},{"location":"reference/database/#gyver.database.drivers.utils.resolve_driver","title":"<code>resolve_driver(driver)</code>","text":"<p>Resolve a driver to its associated DialectInfo.</p> <p>Parameters:</p> Name Type Description Default <code>driver</code> <code>Driver</code> <p>The database driver.</p> required <p>Returns:</p> Name Type Description <code>Dialect</code> <code>Dialect</code> <p>The DialectInfo associated with the provided driver.</p> Source code in <code>gyver/database/drivers/utils.py</code> <pre><code>def resolve_driver(driver: Driver) -&gt; Dialect:\n\"\"\"Resolve a driver to its associated DialectInfo.\n    Args:\n        driver (Driver): The database driver.\n    Returns:\n        Dialect: The DialectInfo associated with the provided driver.\n    \"\"\"\n_table: dict[Driver, Dialect] = {\nDriver.MYSQL: DialectInfo(\ndefault_port=3306,\ndriver=Driver.MYSQL,\ndialect_name=\"mysql\",\nasync_driver=\"aiomysql\",\nsync_driver=\"pymysql\",\nonly_host=False,\n),\nDriver.POSTGRES: DialectInfo(\ndefault_port=5432,\ndriver=Driver.POSTGRES,\ndialect_name=\"postgresql\",\nasync_driver=\"asyncpg\",\nsync_driver=\"psycopg2\",\nonly_host=False,\n),\nDriver.SQLITE: DialectInfo(\ndefault_port=0,\ndriver=Driver.SQLITE,\ndialect_name=\"sqlite\",\nasync_driver=\"aiosqlite\",\nsync_driver=\"\",\nonly_host=True,\n),\nDriver.MARIADB: DialectInfo(\ndefault_port=3306,\ndriver=Driver.MARIADB,\ndialect_name=\"mariadb\",\nasync_driver=\"aiomysql\",\nsync_driver=\"pymysql\",\nonly_host=False,\n),\n}\nreturn _table[driver]\n</code></pre>"},{"location":"reference/model/","title":"Model","text":""},{"location":"reference/model/#gyver.model.Model","title":"<code>Model</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Model is a BaseModel overload with opinions on JSON parsing mutability and alias generation.</p> Configurations <ul> <li>json_loads: Uses utils.json.loads for JSON loading.</li> <li>json_dumps: Uses utils.json.dumps for JSON dumping.</li> <li>frozen: Model instances are frozen by default.</li> <li>orm_mode: Enables ORM mode for this model.</li> <li>alias_generator: Uses utils.to_camel for alias generation.</li> <li>allow_population_by_field_name: Allows population of fields by field name.</li> <li>keep_untouched: Keeps attributes of type lazy untouched during population.</li> </ul>"},{"location":"reference/model/#gyver.model.Model.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Overloads the setattr method to allow lazy fields to work correctly.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required <code>value</code> <code>Any</code> <p>The value to set for the attribute.</p> required"},{"location":"reference/model/#gyver.model.MutableModel","title":"<code>MutableModel</code>","text":"<p>             Bases: <code>Model</code></p> <p>A mutable version of the Model class that allows unfreezing of instances.</p> Configurations <ul> <li>frozen: Model instances are not frozen, allowing mutability.</li> </ul>"},{"location":"reference/url/","title":"URL","text":""},{"location":"reference/url/#gyver.url.Fragment","title":"<code>Fragment</code>","text":"<p>             Bases: <code>Encodable</code></p> <p>Represents an encodable URL fragment.</p> <p>Attributes:</p> Name Type Description <code>fragment_str</code> <code>str</code> <p>The fragment string.</p>"},{"location":"reference/url/#gyver.url.fragment.Fragment.__init__","title":"<code>__init__(fragment_str)</code>","text":"<p>Initialize the Fragment object.</p> <p>Parameters:</p> Name Type Description Default <code>fragment_str</code> <code>str</code> <p>The fragment string.</p> required"},{"location":"reference/url/#gyver.url.fragment.Fragment.__str__","title":"<code>__str__()</code>","text":"<p>Return the fragment string when converting the object to a string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fragment string.</p>"},{"location":"reference/url/#gyver.url.fragment.Fragment.encode","title":"<code>encode()</code>","text":"<p>Encode the fragment string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded fragment string.</p>"},{"location":"reference/url/#gyver.url.fragment.Fragment.set","title":"<code>set(fragment_str)</code>","text":"<p>Set a new fragment string.</p> <p>If the provided string is not already encoded, it will be encoded.</p> <p>Parameters:</p> Name Type Description Default <code>fragment_str</code> <code>str</code> <p>The new fragment string.</p> required <p>Returns:</p> Name Type Description <code>Fragment</code> <code>Self</code> <p>The updated Fragment object.</p>"},{"location":"reference/url/#gyver.url.Netloc","title":"<code>Netloc</code>","text":"<p>             Bases: <code>Encodable</code></p> <p>Represents the network location portion of a URL.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>Optional[str]</code> <p>The username for authentication.</p> <code>password</code> <code>Optional[str]</code> <p>The password for authentication.</p> <code>host</code> <code>str</code> <p>The host name or IP address.</p> <code>port</code> <code>Optional[int]</code> <p>The port number.</p>"},{"location":"reference/url/#gyver.url.netloc.Netloc.__init__","title":"<code>__init__(netloc)</code>","text":"<p>Initialize the Netloc object.</p> <p>Parameters:</p> Name Type Description Default <code>netloc</code> <code>str</code> <p>The network location string.</p> required"},{"location":"reference/url/#gyver.url.netloc.Netloc.encode","title":"<code>encode()</code>","text":"<p>Encode the network location into a string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded network location string.</p>"},{"location":"reference/url/#gyver.url.netloc.Netloc.from_args","title":"<code>from_args(host, username=None, password=None, port=None)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Netloc</code> object from individual arguments.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host name or IP address.</p> required <code>username</code> <code>Optional[str]</code> <p>The username for authentication.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>The password for authentication.</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>The port number.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Netloc</code> <code>Self</code> <p>The created <code>Netloc</code> object.</p>"},{"location":"reference/url/#gyver.url.netloc.Netloc.load","title":"<code>load(netloc)</code>","text":"<p>Load the network location from the given netloc string.</p> <p>Parameters:</p> Name Type Description Default <code>netloc</code> <code>str</code> <p>The network location string.</p> required"},{"location":"reference/url/#gyver.url.netloc.Netloc.merge","title":"<code>merge(netloc)</code>","text":"<p>Merge the properties of the given <code>Netloc</code> object with the current object.</p> <p>Parameters:</p> Name Type Description Default <code>netloc</code> <code>Netloc</code> <p>The <code>Netloc</code> object to merge.</p> required <p>Returns:</p> Name Type Description <code>Netloc</code> <code>Netloc</code> <p>The merged <code>Netloc</code> object.</p>"},{"location":"reference/url/#gyver.url.netloc.Netloc.parse","title":"<code>parse(netloc)</code>","text":"<p>Parse the given netloc string and populate the properties of the Netloc object.</p> <p>Parameters:</p> Name Type Description Default <code>netloc</code> <code>str</code> <p>The netloc string to parse.</p> required"},{"location":"reference/url/#gyver.url.netloc.Netloc.set","title":"<code>set(host=None, username=None, password=None, port=None)</code>","text":"<p>Set the network location properties.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Optional[str]</code> <p>The host name or IP address.</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>The username for authentication.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>The password for authentication.</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>The port number.</p> <code>None</code>"},{"location":"reference/url/#gyver.url.Path","title":"<code>Path</code>","text":"<p>             Bases: <code>Encodable</code></p> <p>Represents a path in a URL.</p> <p>Attributes:</p> Name Type Description <code>segments</code> <code>list[str]</code> <p>List of path segments.</p>"},{"location":"reference/url/#gyver.url.path.Path.isdir","title":"<code>isdir: bool</code>  <code>property</code>","text":"<p>Check if the path represents a directory.</p> <p>Path is considered a directory if it is empty or ends with a trailing slash.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path is a directory, False otherwise.</p>"},{"location":"reference/url/#gyver.url.path.Path.isfile","title":"<code>isfile: bool</code>  <code>property</code>","text":"<p>Check if the path represents a file.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path is a file, False if it is a directory.</p>"},{"location":"reference/url/#gyver.url.path.Path.__init__","title":"<code>__init__(pathstr)</code>","text":"<p>Initialize a Path object.</p> <p>Parameters:</p> Name Type Description Default <code>pathstr</code> <code>str</code> <p>The string representation of the path.</p> required"},{"location":"reference/url/#gyver.url.path.Path.add","title":"<code>add(path)</code>","text":"<p>Add path segments to the existing path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path segments to add. Can be a string or a Path object.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Self</code> <p>The modified Path object.</p>"},{"location":"reference/url/#gyver.url.path.Path.encode","title":"<code>encode()</code>","text":"<p>Encode the path segments into a URL-encoded string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL-encoded path string.</p>"},{"location":"reference/url/#gyver.url.path.Path.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the path by removing redundant segments.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Self</code> <p>The normalized Path object.</p>"},{"location":"reference/url/#gyver.url.path.Path.set","title":"<code>set(path)</code>","text":"<p>Set the path segments to a new value.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The new path segments. Can be a string or a Path object.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Self</code> <p>The modified Path object.</p>"},{"location":"reference/url/#gyver.url.Query","title":"<code>Query</code>","text":"<p>             Bases: <code>Encodable</code></p> <p>Represents a query string and provides methods to manipulate and encode it.</p> <p>Attributes:</p> Name Type Description <code>params</code> <code>defaultdict[str, list[str]]</code> <p>The dictionary containing query parameters.</p>"},{"location":"reference/url/#gyver.url.query.Query.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieves the values of a query parameter using the square bracket syntax.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The parameter key.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The list of parameter values.</p>"},{"location":"reference/url/#gyver.url.query.Query.__init__","title":"<code>__init__(querystr)</code>","text":"<p>Initializes the Query object with the provided query string.</p> <p>Parameters:</p> Name Type Description Default <code>querystr</code> <code>str</code> <p>The input query string to parse.</p> required"},{"location":"reference/url/#gyver.url.query.Query.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets a query parameter using the square bracket syntax.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The parameter key.</p> required <code>value</code> <code>str</code> <p>The parameter value.</p> required"},{"location":"reference/url/#gyver.url.query.Query.add","title":"<code>add(args=None, /, **params)</code>","text":"<p>Adds query parameters to the Query object.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Optional[Mapping[str, str]]</code> <p>Additional query parameters as a mapping object.</p> <code>None</code> <code>**params</code> <code>str</code> <p>Additional query parameters as keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Query</code> <code>Self</code> <p>The modified Query object.</p>"},{"location":"reference/url/#gyver.url.query.Query.encode","title":"<code>encode()</code>","text":"<p>Encodes the query object into a string representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded query string.</p>"},{"location":"reference/url/#gyver.url.query.Query.omit_empty_equal","title":"<code>omit_empty_equal()</code>","text":"<p>Encodes the query object into a string representation, omitting the equal sign if a value is empty.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded query string.</p>"},{"location":"reference/url/#gyver.url.query.Query.remove","title":"<code>remove(*keys)</code>","text":"<p>Removes query parameters from the Query object.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str</code> <p>The parameter keys to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Query</code> <code>Self</code> <p>The modified Query object.</p>"},{"location":"reference/url/#gyver.url.query.Query.set","title":"<code>set(args=None, /, **params)</code>","text":"<p>Sets the query parameters, replacing any existing parameters.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Optional[Mapping[str, str]]</code> <p>New query parameters as a mapping object.</p> <code>None</code> <code>**params</code> <code>str</code> <p>New query parameters as keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Query</code> <code>Self</code> <p>The modified Query object.</p>"},{"location":"reference/url/#gyver.url.query.Query.sort","title":"<code>sort()</code>","text":"<p>Sorts the query parameters in lexicographic order based on the parameter names.</p> <p>Returns:</p> Name Type Description <code>Query</code> <code>Self</code> <p>The modified Query object.</p>"},{"location":"reference/url/#gyver.url.URL","title":"<code>URL</code>","text":"<p>             Bases: <code>Encodable</code></p> <p>Class representing a URL object.</p> <p>Attributes:</p> Name Type Description <code>scheme</code> <code>str</code> <p>The URL scheme.</p> <code>netloc</code> <code>Netloc</code> <p>The URL netloc.</p> <code>path</code> <code>Path</code> <p>The URL path.</p> <code>query</code> <code>Query</code> <p>The URL query parameters.</p> <code>fragment</code> <code>Fragment</code> <p>The URL fragment.</p>"},{"location":"reference/url/#gyver.url.core.URL.__init__","title":"<code>__init__(val)</code>","text":"<p>Initialize a URL object.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>The URL string.</p> required"},{"location":"reference/url/#gyver.url.core.URL.add","title":"<code>add(queryasdict=None, /, path=None, query=None, fragment=None, netloc=None, netloc_obj=None, scheme=None)</code>","text":"<p>Add components to the URL.</p> <p>Parameters:</p> Name Type Description Default <code>queryasdict</code> <code>Optional[Mapping[str, str]]</code> <p>Dictionary-like object representing query parameters.</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Path string to add to the URL.</p> <code>None</code> <code>query</code> <code>Optional[Mapping[str, str]]</code> <p>Dictionary-like object representing additional query parameters.</p> <code>None</code> <code>fragment</code> <code>Optional[str]</code> <p>Fragment string to set for the URL.</p> <code>None</code> <code>netloc</code> <code>Optional[str]</code> <p>Netloc string to set for the URL.</p> <code>None</code> <code>netloc_obj</code> <code>Optional[Netloc]</code> <p>Netloc object to merge with the existing netloc.</p> <code>None</code> <code>scheme</code> <code>Optional[str]</code> <p>Scheme to set for the URL.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>URL</code> <code>Self</code> <p>The updated URL object.</p>"},{"location":"reference/url/#gyver.url.core.URL.copy","title":"<code>copy()</code>","text":"<p>Create a copy of the URL object.</p> <p>Returns:</p> Name Type Description <code>URL</code> <code>Self</code> <p>The copied URL object.</p>"},{"location":"reference/url/#gyver.url.core.URL.encode","title":"<code>encode(append_empty_equal=True)</code>","text":"<p>Encode the URL object as a URL string.</p> <p>Parameters:</p> Name Type Description Default <code>append_empty_equal</code> <code>bool</code> <p>Whether to append empty values with an equal sign in the query string.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded URL string.</p>"},{"location":"reference/url/#gyver.url.core.URL.from_netloc","title":"<code>from_netloc(netloc=None, *, username=None, password=None, host=None, port=None)</code>  <code>classmethod</code>","text":"<p>Create a URL object from a netloc.</p> <p>Parameters:</p> Name Type Description Default <code>netloc</code> <code>Optional[Netloc]</code> <p>Netloc object to set for the URL.</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>Username for the netloc.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Password for the netloc.</p> <code>None</code> <code>host</code> <code>Optional[str]</code> <p>Host for the netloc.</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>Port for the netloc.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>URL</code> <code>Self</code> <p>The URL object created from the netloc.</p>"},{"location":"reference/url/#gyver.url.core.URL.load","title":"<code>load(val)</code>","text":"<p>Parse the given URL string and populate the properties of the URL object.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>The URL string.</p> required"},{"location":"reference/url/#gyver.url.core.URL.set","title":"<code>set(queryasdict=None, /, path=None, query=None, fragment=None, netloc=None, netloc_obj=None, scheme=None)</code>","text":"<p>Set components of the URL.</p> <p>Parameters:</p> Name Type Description Default <code>queryasdict</code> <code>Optional[Mapping[str, str]]</code> <p>Dictionary-like object representing query parameters.</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Path string to set for the URL.</p> <code>None</code> <code>query</code> <code>Optional[Mapping[str, str]]</code> <p>Dictionary-like object representing query parameters.</p> <code>None</code> <code>fragment</code> <code>Optional[str]</code> <p>Fragment string to set for the URL.</p> <code>None</code> <code>netloc</code> <code>Optional[str]</code> <p>Netloc string to set for the URL.</p> <code>None</code> <code>netloc_obj</code> <code>Optional[Netloc]</code> <p>Netloc object to set as the netloc.</p> <code>None</code> <code>scheme</code> <code>Optional[str]</code> <p>Scheme to set for the URL.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>URL</code> <code>Self</code> <p>The updated URL object.</p>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#gyver.utils.lazy","title":"<code>lazy</code>","text":""},{"location":"reference/utils/#gyver.utils.lazy.asynclazyfield","title":"<code>asynclazyfield</code>","text":"<p>             Bases: <code>lazy</code>, <code>typing.Generic[SelfT, T]</code></p> <p>A descriptor class for asynchronously lazy-loading attributes on a class.</p> <p>When the decorated method is accessed on an instance, it will check if the instance has an attribute with the same name as the method but with an underscore prefix. If the attribute does not exist, it will call the decorated asynchronous method on the instance and set the result as the attribute's value. Subsequent accesses will return the cached value, avoiding unnecessary recalculation or computation.</p>"},{"location":"reference/utils/#gyver.utils.lazy.asynclazyfield.__call__","title":"<code>__call__(instance)</code>  <code>async</code>","text":"<p>Call the asynchronous method to load the attribute's value.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>SelfT</code> <p>The instance of the class.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The loaded value of the attribute.</p>"},{"location":"reference/utils/#gyver.utils.lazy.asynclazyfield.__get__","title":"<code>__get__(instance, owner=None)</code>","text":"<p>Get the wrapped asynchronous method or the descriptor itself.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>typing.Optional[SelfT]</code> <p>The instance of the class.</p> required <code>owner</code> <code>type[SelfT]</code> <p>The class that owns the descriptor.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Union[typing.Callable[[], typing.Coroutine[Any, Any, T]], Self]</code> <p>Union[ typing.Callable[[], typing.Coroutine[Any, Any, T]], Self</p> <code>typing.Union[typing.Callable[[], typing.Coroutine[Any, Any, T]], Self]</code> <p>]: The asynchronous method or the descriptor itself.</p>"},{"location":"reference/utils/#gyver.utils.lazy.asynclazyfield.__init__","title":"<code>__init__(func)</code>","text":"<p>Initializes the asynclazyfield descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The asynchronous function that will be decorated.</p> required"},{"location":"reference/utils/#gyver.utils.lazy.asynclazyfield.__set_name__","title":"<code>__set_name__(owner, name)</code>","text":"<p>Set the public and private names for the asynclazyfield descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type</code> <p>The class that owns the descriptor.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required"},{"location":"reference/utils/#gyver.utils.lazy.lazy","title":"<code>lazy</code>","text":"<p>Represents a lazy descriptor</p>"},{"location":"reference/utils/#gyver.utils.lazy.lazyfield","title":"<code>lazyfield</code>","text":"<p>             Bases: <code>lazy</code>, <code>typing.Generic[SelfT, T]</code></p> <p>A descriptor class that can be used as a decorator for a method on a class. When the decorated method is accessed on an instance, it will check if the instance has an attribute with the same name as the method but with an underscore prefix. If the attribute does not exist, it will call the decorated method on the instance and set the result as the attribute's value. Subsequent accesses will return the cached value, avoiding unnecessary recalculation or computation.</p>"},{"location":"reference/utils/#gyver.utils.lazy.lazyfield.__init__","title":"<code>__init__(func)</code>","text":"<p>Initializes the lazy field descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function that will be decorated.</p> required"},{"location":"reference/utils/#gyver.utils.lazy.lazyfield.__set_name__","title":"<code>__set_name__(owner, name)</code>","text":"<p>Sets the public and private names for the lazy field descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>type</code> <p>The class that owns the descriptor.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required"},{"location":"reference/utils/#gyver.utils.lazy.dellazy","title":"<code>dellazy(instance, attribute, bypass_delattr=False)</code>","text":"<p>Delete the value of a lazy-loaded property on an instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance to delete the property from.</p> required <code>attribute</code> <code>str</code> <p>The name of the lazy-loaded property.</p> required <code>bypass_delattr</code> <code>bool</code> <p>If True, directly delete the attribute using <code>object.__delattr__</code>                    to bypass immutability issues. (default: False)</p> <code>False</code> <p>Raises:</p> Type Description <code>InvalidField</code> <p>If the attribute is not a lazy descriptor.</p>"},{"location":"reference/utils/#gyver.utils.lazy.force_del","title":"<code>force_del(instance, attribute)</code>","text":"<p>Forcefully delete the value of a lazy-loaded property on an instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance to set the property on.</p> required <code>attribute</code> <code>str</code> <p>The name of the lazy-loaded property.</p> required"},{"location":"reference/utils/#gyver.utils.lazy.force_set","title":"<code>force_set(instance, attribute, value)</code>","text":"<p>Forcefully set the value of a lazy-loaded property on an instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance to set the property on.</p> required <code>attribute</code> <code>str</code> <p>The name of the lazy-loaded property.</p> required <code>value</code> <code>Any</code> <p>The value to set for the property.</p> required"},{"location":"reference/utils/#gyver.utils.lazy.setlazy","title":"<code>setlazy(instance, attribute, value, bypass_setattr=False)</code>","text":"<p>Set the value of a lazy-loaded property on an instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance to set the property on.</p> required <code>attribute</code> <code>str</code> <p>The name of the lazy-loaded property.</p> required <code>value</code> <code>Any</code> <p>The value to set for the property.</p> required <code>bypass_setattr</code> <code>bool</code> <p>If True, directly set the attribute using <code>object.__setattr__</code>                    to bypass immutability issues. (default: False)</p> <code>False</code> <p>Raises:</p> Type Description <code>InvalidField</code> <p>If the attribute is not a lazy descriptor.</p>"},{"location":"reference/utils/#gyver.utils.json","title":"<code>json</code>","text":""},{"location":"reference/utils/#gyver.utils.json.loads","title":"<code>loads: typing.Callable[[typing.Union[str, bytes, bytearray, memoryview]], typing.Any] = orjson.loads</code>  <code>module-attribute</code>","text":"<p>Deserialize a JSON string to a Python object.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>(bytes, str, bytearray, memoryview)</code> <p>The JSON string to be deserialized.</p> required <p>Returns:</p> Type Description <code>typing.Callable[[typing.Union[str, bytes, bytearray, memoryview]], typing.Any]</code> <p>typing.Any: The deserialized Python object.</p>"},{"location":"reference/utils/#gyver.utils.json.dump","title":"<code>dump(val, fp, *, default=None)</code>","text":"<p>Serialize a Python object and write the JSON-formatted string to a text file object.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>typing.Any</code> <p>The Python object to be serialized.</p> required <code>fp</code> <code>typing.TextIO</code> <p>The text file object to write the JSON-formatted string to.</p> required <code>default</code> <code>typing.Any</code> <p>A default value to be used if an object is not serializable. Defaults to None.</p> <code>None</code>"},{"location":"reference/utils/#gyver.utils.json.dumps","title":"<code>dumps(val, *, default=None)</code>","text":"<p>Serialize a Python object to a JSON-formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>typing.Any</code> <p>The Python object to be serialized.</p> required <code>default</code> <code>typing.Any</code> <p>A default value to be used if an object is not serializable. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The JSON-formatted string representing the serialized object.</p>"},{"location":"reference/utils/#gyver.utils.json.load","title":"<code>load(fdes)</code>","text":"<p>Deserialize a JSON-formatted string from a text file object.</p> <p>Parameters:</p> Name Type Description Default <code>fdes</code> <code>typing.TextIO</code> <p>The text file object to read the JSON-formatted string from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>typing.Any: The deserialized Python object.</p>"},{"location":"reference/utils/#gyver.utils.timezone","title":"<code>timezone</code>","text":""},{"location":"reference/utils/#gyver.utils.timezone.make_now_factory","title":"<code>make_now_factory(tz)</code>","text":"<p>Create a function to get the current aware datetime with a specific timezone.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo</code> <p>The timezone for the datetime factory.</p> required <p>Returns:</p> Type Description <code>Callable[[], datetime]</code> <p>Callable[[], datetime]: A function that returns the current datetime in the specified timezone.</p>"},{"location":"reference/utils/#gyver.utils.timezone.now","title":"<code>now(tz=timezone.utc)</code>","text":"<p>Get the current aware datetime.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo</code> <p>The timezone for the datetime (default is UTC).</p> <code>timezone.utc</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The current datetime in the specified timezone.</p>"},{"location":"reference/utils/#gyver.utils.timezone.today","title":"<code>today(tz=timezone.utc)</code>","text":"<p>Get today's aware date.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo</code> <p>The timezone for the date (default is UTC).</p> <code>timezone.utc</code> <p>Returns:</p> Name Type Description <code>date</code> <code>date</code> <p>Today's date in the specified timezone.</p>"},{"location":"reference/utils/#gyver.utils.strings","title":"<code>strings</code>","text":""},{"location":"reference/utils/#gyver.utils.strings.make_lex_separator","title":"<code>make_lex_separator(outer_cast, cast=str)</code>","text":"<p>Create a lexer-based separator function.</p> <p>Parameters:</p> Name Type Description Default <code>outer_cast</code> <code>type</code> <p>The type to cast the resulting separated values into.</p> required <code>cast</code> <code>type</code> <p>The type to which each individual item will be cast (default: str).</p> <code>str</code> <p>Returns:</p> Type Description <code>Callable[[str], OuterCastT]</code> <p>Callable[[str], OuterCastT]: A callable that separates a string into an instance of outer_cast with casted items.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; comma_separated = make_lex_separator(tuple, str)\n&gt;&gt;&gt; result = comma_separated(\"a, b, c\")\n&gt;&gt;&gt; print(result)\n('a', 'b', 'c')\n</code></pre>"},{"location":"reference/utils/#gyver.utils.strings.to_camel","title":"<code>to_camel(snake_string)</code>","text":"<p>Convert a snake_case string to camelCase.</p> <p>Parameters:</p> Name Type Description Default <code>snake_string</code> <code>str</code> <p>The snake_case string to be converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted string in camelCase.</p>"},{"location":"reference/utils/#gyver.utils.strings.to_lower_kebab","title":"<code>to_lower_kebab(camel_string)</code>","text":"<p>Convert camelCase strings to kebab-case.</p> <p>Parameters:</p> Name Type Description Default <code>camel_string</code> <code>str</code> <p>The camelCase string to be converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted string in kebab-case.</p>"},{"location":"reference/utils/#gyver.utils.strings.to_pascal","title":"<code>to_pascal(snake_string)</code>","text":"<p>Convert a snake_case string to PascalCase.</p> <p>Parameters:</p> Name Type Description Default <code>snake_string</code> <code>str</code> <p>The snake_case string to be converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted string in PascalCase.</p>"},{"location":"reference/utils/#gyver.utils.strings.to_snake","title":"<code>to_snake(camel_string)</code>","text":"<p>Convert a camelCase string to snake_case.</p> <p>Parameters:</p> Name Type Description Default <code>camel_string</code> <code>str</code> <p>The camelCase string to be converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted string in snake_case.</p>"},{"location":"reference/utils/#gyver.utils.strings.upper_camel","title":"<code>upper_camel(snake_string)</code>","text":"Deprecated <p>Use to_pascal instead.</p>"},{"location":"reference/utils/#gyver.utils.finder","title":"<code>finder</code>","text":""},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder","title":"<code>FinderBuilder</code>","text":"<p>Builder class to construct a Finder instance with various configurations.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.add_validator","title":"<code>add_validator(validator)</code>","text":"<p>Add a validation function to the builder.</p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>Validator</code> <p>The validation function to add.</p> required <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.build","title":"<code>build(look_on=None)</code>","text":"<p>Build a Finder instance with the provided configurations.</p> <p>Parameters:</p> Name Type Description Default <code>look_on</code> <code>Optional[pathlib.Path]</code> <p>The path to focus the search on (default: None).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>_Finder</code> <code>_Finder</code> <p>The built Finder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.child_of","title":"<code>child_of(*types)</code>","text":"<p>Add a class validator that checks if objects are subclasses of the provided types.</p> <p>Parameters:</p> Name Type Description Default <code>*types</code> <code>type</code> <p>Types to validate against.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.exclude","title":"<code>exclude(*paths)</code>","text":"<p>Exclude paths from search.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>StrOrPath</code> <p>Paths to exclude.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.exclude_default","title":"<code>exclude_default()</code>","text":"<p>Exclude default paths (e.g., 'init.py', 'pycache') from search.</p> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.find","title":"<code>find(look_on=None)</code>","text":"<p>Find and return located objects using the provided configurations.</p> <p>Parameters:</p> Name Type Description Default <code>look_on</code> <code>Optional[pathlib.Path]</code> <p>The path to focus the search on (default: None).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, typing.Any]</code> <p>The dictionary containing the located objects.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.from_cwd","title":"<code>from_cwd()</code>","text":"<p>Set the root path for the finder to the current working directory.</p> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.from_package","title":"<code>from_package(stack_position=1)</code>","text":"<p>Set the root path for the finder to the calling package root.</p> <p>Parameters:</p> Name Type Description Default <code>stack_position</code> <code>int</code> <p>The position in the stack trace of the calling function (default: 1).</p> <code>1</code> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.from_path","title":"<code>from_path(path)</code>","text":"<p>Set the root path for the finder from a provided path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>pathlib.Path</code> <p>The root path.</p> required <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p> <p>Raises:</p> Type Description <code>InvalidPath</code> <p>If the path does not exist</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.from_project","title":"<code>from_project()</code>","text":"<p>Set the root path for the finder to the project root.</p> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.instance_of","title":"<code>instance_of(*types)</code>","text":"<p>Add an instance validator that checks if objects are instances of the provided types.</p> <p>Parameters:</p> Name Type Description Default <code>*types</code> <code>type</code> <p>Types to validate against.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>FinderBuilder</code> <code>Self</code> <p>The FinderBuilder instance.</p>"},{"location":"reference/utils/#gyver.utils.finder.FinderBuilder.reset","title":"<code>reset()</code>","text":"<p>Reset the builder to its initial state.</p>"},{"location":"reference/utils/#gyver.utils.finder.class_validator","title":"<code>class_validator(*types)</code>","text":"<p>Create a class validator that checks if objects are subclasses of the provided types.</p> <p>Parameters:</p> Name Type Description Default <code>*types</code> <code>type</code> <p>Types to validate against.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Validator</code> <code>Validator</code> <p>The validator function.</p>"},{"location":"reference/utils/#gyver.utils.finder.instance_validator","title":"<code>instance_validator(*types)</code>","text":"<p>Create an instance validator that checks if objects are instances of the provided types.</p> <p>Parameters:</p> Name Type Description Default <code>*types</code> <code>type</code> <p>Types to validate against.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Validator</code> <code>Validator</code> <p>The validator function.</p>"},{"location":"reference/utils/#gyver.utils.finder.iterate_module","title":"<code>iterate_module(modpath, resolver)</code>","text":"<p>Iterate through a module using a resolver to map paths to module names.</p> <p>Parameters:</p> Name Type Description Default <code>modpath</code> <code>pathlib.Path</code> <p>The path to the module.</p> required <code>resolver</code> <code>PathConverter</code> <p>A path converter to map paths to module names.</p> required <p>Yields:</p> Type Description <code>str</code> <p>tuple[str, Any]: A tuple containing the name and object of each item in the module.</p>"},{"location":"reference/utils/#gyver.utils.finder.make_modulename_resolver","title":"<code>make_modulename_resolver(root, path_converter=pathlib.Path.as_posix)</code>","text":"<p>Create a module name resolver based on a root path.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>pathlib.Path</code> <p>The root path to resolve from.</p> required <code>path_converter</code> <code>PathConverter</code> <p>A path converter function (default: pathlib.Path.as_posix).</p> <code>pathlib.Path.as_posix</code> <p>Returns:</p> Name Type Description <code>PathConverter</code> <code>PathConverter</code> <p>A callable that resolves a path into a module name.</p>"},{"location":"reference/utils/#gyver.utils.helpers","title":"<code>helpers</code>","text":""},{"location":"reference/utils/#gyver.utils.helpers.DeprecatedClass","title":"<code>DeprecatedClass</code>","text":"<p>A class to mark as deprecated.</p> <p>This class issues a deprecation warning when instantiated.</p>"},{"location":"reference/utils/#gyver.utils.helpers.cache","title":"<code>cache(f)</code>","text":"<p>Cache the result of a function. It uses <code>functools.cache</code> and just adds proper type hints to it.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[P, T]</code> <p>The function to be cached.</p> required <p>Returns:</p> Type Description <code>Callable[P, T]</code> <p>Callable[P, T]: The cached version of the function.</p>"},{"location":"reference/utils/#gyver.utils.helpers.deprecated","title":"<code>deprecated(func)</code>","text":"<p>Mark a function as deprecated and issue a warning when it's used.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, T]</code> <p>The function to be marked as deprecated.</p> required <p>Returns:</p> Type Description <code>Callable[P, T]</code> <p>Callable[P, T]: A wrapped version of the function that issues a warning on use.</p>"},{"location":"reference/utils/#gyver.utils.helpers.merge_dicts","title":"<code>merge_dicts(left, right, on_conflict, merge_sequences=True)</code>","text":"<p>Merge two dictionaries with customizable conflict resolution strategy.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>dict</code> <p>The left dictionary to merge.</p> required <code>right</code> <code>dict</code> <p>The right dictionary to merge.</p> required <code>on_conflict</code> <code>Literal['strict', 'left', 'right']</code> <p>The conflict resolution strategy to use.</p> <ul> <li>'strict': Raise a MergeConflict exception if conflicts occur.</li> <li>'left': Prioritize the values from the left dictionary in case of conflicts.</li> <li>'right': Prioritize the values from the right dictionary in case of conflicts.</li> </ul> required <code>merge_sequences</code> <code>bool</code> <p>Indicates whether to merge sequences (lists, sets, tuples) or skip them.</p> <ul> <li>If True, sequences will be merged based on the conflict resolution strategy.</li> <li>If False, sequences will be skipped, and the value from the chosen (defaults to left on strict) dictionary will be used. Default is True.</li> </ul> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The merged dictionary.</p> <p>Raises:</p> Type Description <code>MergeConflict</code> <p>If conflicts occur and the conflict resolution strategy is set to 'strict'.</p>"},{"location":"reference/utils/#gyver.utils.exc","title":"<code>exc</code>","text":""},{"location":"reference/utils/#gyver.utils.exc.panic","title":"<code>panic(exc, message, *args)</code>","text":"<p>Create an instance of the specified exception class with a modified error message.</p> <p>This function creates an exception instance by calling the constructor of the specified exception class with the modified error message and any additional arguments provided.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>type[T]</code> <p>The exception class to instantiate.</p> required <code>message</code> <code>str</code> <p>The error message for the exception.</p> required <code>*args</code> <code>Any</code> <p>Additional arguments to pass to the exception constructor.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the specified exception class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class CustomError(Exception):\n...     pass\n...\n&gt;&gt;&gt; error = panic(CustomError, \"Something went wrong\", \"additional_info\")\n&gt;&gt;&gt; isinstance(error, CustomError)\nTrue\n&gt;&gt;&gt; str(error)\n'Something went wrong! additional_info'\n</code></pre>"},{"location":"usage/config/","title":"Config","text":"<p><code>Config</code> is the core feature to all <code>gyver</code> providers. It has helpers to handle environment variables and create config classes in a declarative way. Gyver prioritizes variables from the environment before environments read from files.</p> <p>Package</p> <p>All config features except the AdapterConfigFactory and as_config are isolated in the <code>env-star</code> package and can be installed as a standalone. However you will import using <code>from config import ...</code> instead of  <code>from gyver.config import ...</code></p>"},{"location":"usage/config/#config-class","title":"Config Class","text":"<p>The Config class is responsible for loading variables from the environment.</p> <pre><code>from gyver.config import Config\nconfig = Config()\n# will search for MY_ENV_VAR on the environment\n# or raise a `config.exceptions.MissingName` error\nMY_ENV_VAR = config('MY_ENV_VAR')\n# will search for CAST_ENV_VAR and try to pass as a parameter\n# to int. on fail raises `config.exceptions.InvalidCast`\nCAST_ENV_VAR = config('CAST_ENV_VAR', int)\n# will search for DEFAULT_ENV_VAR and if not found will\n# use 1 by default\nDEFAULT_ENV_VAR = config('DEFAULT_ENV_VAR', int, default=1)\n</code></pre> <p>Config also accepts two params:</p> <ul> <li><code>env_file: str | Path | None</code> which will import the dotenv file contents if the file exist. </li> <li>mapping: gyver.config.EnvMapping which uses to read the keys, by default uses a wrapper over <code>os.environ</code></li> </ul>"},{"location":"usage/config/#envconfig","title":"EnvConfig","text":"<p>EnvConfig is a config subclass that uses an dotenv, depending on the value of the CONFIG_ENV in the environment. It uses a env enum and applies a weight to each possible value:</p> <ul> <li>Env.(PRD &gt; DEV &gt; TEST &gt; LOCAL )</li> </ul> <p>These values are read from the environment as lowercase.</p> <pre><code>from gyver.config import EnvConfig, Env, DotFile\n# Here EnvConfig accepts may read one of two env files\n# depending on the CONFIG_ENV value.\n# If CONFIG_ENV=prd, loads the .env file\n# If CONFIG_ENV=dev or lower, loads the .env-dev file\nconfig = EnvConfig(\nDotfile('.env-dev', Env.DEV, apply_to_lower=True), \nDotFile('.env', Env.PRD)\n)\nMY_ENV_VAR = config('MY_ENV_VAR')\n</code></pre> <p>For more information on EnvConfig's attributes check the API Reference</p>"},{"location":"usage/config/#grouping-variables-in-classes","title":"Grouping variables in classes","text":"<p>gyver.config is also tuned to load classes as configuration by introspecting into their fields. In this way you can use classes to group environment variables together and add custom prefixes and defaults to it.</p> <p>Info</p> <p>Currently it will support any class defined by:</p> <pre><code>- Pydantic V1\n- attr.s\n- dataclasses\n- gyver-attrs\n</code></pre> <p>But it is more properly prepared to deal with the helper gyver-attrs method as_config</p> <pre><code>from gyver.config import Config, AdapterConfigFactory, as_config\n# Create a class decorated by as_config (or create a dataclass, a pydantic model or an attrs.define class)\n@as_config\nclass MyProviderConfig:\n# the dunder prefix attribute will be used to \n# make the names to the environment variables\n# for example: with the name attribute\n# AdapterConfigFactory will lookup for SERVICE_NAME in config\n# By default is an empty string\n__prefix__ = 'service'\n# the without prefix dunder attribute will be used\n# to avoid prefixing to the attributes passed\n__without_prefix__ = (\n'max_connections', \n'connection_recycle'\n)\n# the type here will be used as cast in the call function\nname: str\nmax_connections: int = 10\nconnection_recycle: int = 3600\nconfig = Config() # or EnvConfig\n# AdapterConfigFactory starts with a config instance, or if none, it will use a default\n# Config()\nfactory = AdapterConfigFactory(config)\n# here the factory will do:\n# MyProviderConfig(\n#   name=config('SERVICE_NAME', str),\n#   max_connections=config('MAX_CONNECTIONS', int, 10)\n#   connection_recycle=config('CONNECTION_RECYCLE', int, 3600)\n# )\n# AdapterConfigFactory will retry with lowercase as well before raising\n# `config.exceptions.MissingName`\nmy_provider_config = config_loader.load(MyProviderConfig)\n# here is essentially the same as\n# my_provider_factory = lambda: config_loader.load(MyProviderConfig)\nmy_provider_factory = config_loader.maker(MyProviderConfig)\n</code></pre> <p>load also accepts presets as keyword arguments. The keyword arguments passed to <code>.load</code> will not be searched in the config.</p> <p><code>AdapterConfigFactory</code> also has the function <code>.resolve_confignames(cls, root: Path) -&gt; dict</code> which uses finder to lookup at <code>root</code> and returns all possible environment variables based on the marked configuration classes, if you are not using as_config but still want this to find your configuration class, decorate the class with mark.</p>"},{"location":"usage/config/#marking-classes-as-config","title":"Marking Classes as Config","text":"<p>Use the mark function to mark a class as a config class. When a class is marked using this function, it helps improve the accuracy of identifying classes intended for use as config classes. This is particularly useful when using the resolve_confignames function to determine the environment variables that a class expects.</p> <p>Note</p> <p>Note that even if not marked as a config class, load will still process the class attributes correctly, however resolve_confignames will not be able to find this class and show it.</p> <pre><code>from gyver.config import mark\nfrom pydantic import BaseModel\n@mark\nclass MyConfigClass(BaseModel):\n# Class fields...\n# Use resolve_confignames to \n# find environment variables \n# associated with marked config classes\nconfig_variables = AdapterConfigFactory.resolve_confignames(Path('/path/to/project'))\n# This will only include classes \n# marked using the mark function\n# Avoiding false positives and \n# providing accurate results\n</code></pre>"},{"location":"usage/config/#helpers","title":"Helpers","text":"<p>[gyver.config] comes with various helpers for some common cases.</p> <ul> <li>boolean_cast can be used instead of passing bool directly and only validating if the value is truthy.     Example:     <pre><code># TRUE_ENV_VAR=1\n# FALSE_ENV_VAR=False\nfrom gyver.config import Config, boolean_cast\nconfig = Config()\n# Here the value returned is True, \n# but not because it is reading properly the value\n# instead because the value is not empty\nconfig(\"TRUE_ENV_VAR\", bool)\n# Now boolean_cast is effectly evaluating if the value exists and \n# if the value.lower() in (1, \"true\")\nconfig(\"TRUE_ENV_VAR\", boolean_cast)\n# Here it will wrongly return the value as True\n# because it is only evaluating if the value is not empty\nconfig(\"FALSE_ENV_VAR\", bool)\n# Here it will return false because it is evaluating\n# value.lower() in (0, \"false\", \"\")\nconfig(\"FALSE_ENV_VAR\", boolean_cast)\n</code></pre></li> <li>valid_path is a utility function that converts a string to a Path object and checks if the path exists.     Example:     <pre><code>#PATH_ENV=/path/to/existing/file.txt\nfrom gyver.config import valid_path, Config\nconfig = Config()\n# Here config properly evaluates the path and checks\n# if it .exists() or raises an Exception if it does not.\nconfig(\"PATH_ENV\", valid_path)\n</code></pre></li> <li> <p>joined_cast is a helper function that enables joined casting.     Example:     <pre><code># SHOULD_BE_INT=1.034\nfrom gyver.config import Config, joined_cast\nconfig = Config()\n# here joined cast will receive 1.034 string, \n# then cast it to float and then cast it to int\n# providing the expected value with n transformations\nconfig(\"SHOULD_BE_INT\", joined_cast(float).cast(int))\n</code></pre></p> </li> <li> <p>with_rule is a helper function that applies a rule check to a value and raises an InvalidEnv exception if the rule is not satisfied.     Example:     <pre><code>    # DB_MAX_CONNECTIONS=-3\nfrom gyver.config import with_rule, Config, joined_cast\nconfig = Config()\ndef should_be_positive(value: int):\nreturn value &gt; 0\n# Here with rule will raise an exception, because\n# DB_MAX_CONNECTIONS does not pass the rule expected `should_be_positive`\nconfig(\"DB_MAX_CONNECTIONS\", joined_cast(int).cast(with_rule(should_be_positive)))\n# However you can quickly fix that just by joining another function\n# now the rule does not raise errors and the value returns correctly\nconfig(\"DB_MAX_CONNECTIONS\", joined_cast(int).cast(lambda val: min(1, val)).cast(with_rule(should_be_positive)))\n</code></pre></p> </li> </ul>"},{"location":"usage/config/#nested-config-classes","title":"Nested Config Classes","text":"<p>Gyver config can also support nested configurations as such:</p> <pre><code>from gyver.config import as_config, AdapterConfigFactory\n@as_config\nclass PoolConfig:\nsize: int\nrecycle: int = 3600\n@as_config\nclass MyDbConfig:\npool: PoolConfig\nhost: str\nport: int\nfactory = AdapterConfigFactory()\n# This will look for\n# DB_HOST\n# DB_PORT\n# DB_POOL__SIZE\n# DB_POOL__RECYCLE\nfactory.load(MyDbConfig, __prefix__=\"db\")\n# if you want to use a different separator, \n# then you can do it like this\n# this will look for\n# ...\n# DB_POOL--SIZE\n# DB_POOL--RECYCLE\nfactory.load(MyDbConfig, __prefix__=\"db\", __sep__=\"--\")\n</code></pre>"},{"location":"usage/model/","title":"Model","text":"<p><code>Model</code> is an abstract class used to create python objects with a few opinions. It is built entirely using <code>pydantic.BaseModel</code> and <code>orjson</code> for json parsing. By default all Model classes are:</p> <ul> <li>frozen</li> <li>with orm_mode enabled</li> <li>with allow_population_by_field_name enabled</li> <li>with support for all gyver features</li> <li>with alias generation for camelCase</li> </ul>"},{"location":"usage/model/#usage","title":"Usage","text":"<pre><code>from gyver.model import Model\nclass Person(Model):\nname: str\nemail: str\ntype_: int = 0\n</code></pre>"},{"location":"usage/model/#mutable-model","title":"Mutable Model","text":"<p>If you need all the features of Model but don't want the immutability, you can use <code>gyver.model.MutableModel</code></p>"},{"location":"usage/url/","title":"URL","text":"<p>The URL module offers a convenient way of interacting with the different parts of a URL.</p>"},{"location":"usage/url/#initialization","title":"Initialization","text":"<p>You can create a new instance of the URL class by passing a string to the constructor.</p> <pre><code>from gyver.url import URL\nurl = URL(\"https://www.example.com/path?key=value#fragment\")\n</code></pre>"},{"location":"usage/url/#properties","title":"Properties","text":"<p>The URL class has the following properties:</p> <ul> <li><code>scheme</code>: The scheme of the URL (e.g. \"http\", \"https\").</li> <li><code>netloc</code>: The network location of the URL. It includes the hostname and port, as well as the username and password if present.</li> <li><code>path</code>: The path of the URL.</li> <li><code>query</code>: The query string of the URL, as a Query object.</li> <li><code>fragment</code>: The fragment of the URL, as a Fragment object.</li> <li><code>port</code>: The port of the URL, if present.</li> </ul>"},{"location":"usage/url/#methods","title":"Methods","text":"<p>The URL class has the following methods:</p> <ul> <li><code>load(val: str)</code></li> </ul> <p>You can use this method to update the URL with a new string. It will update all the properties accordingly.</p> <ul> <li><code>encode(self, omit_empty_equal: bool = True):</code></li> </ul> <p>This method returns the resolved string representation of the URL. By default, it will append an equal sign to null query parameters. If omit_empty_equal is set to False, null query parameters will be represented by only their name.</p> <ul> <li><code>add(...)</code></li> </ul> <p>This method allows you to add new elements to the URL. You can add new values to the query, path, fragment, scheme or netloc by passing the corresponding arguments.</p> <ul> <li>set(...)</li> </ul> <p>This method allows you to set elements of the URL. You can set new values to the query, path, fragment, scheme or netloc by passing the corresponding arguments.</p>"},{"location":"usage/url/#element-classes","title":"Element classes","text":"<p>The URL class uses the following element classes to handle the different parts of the URL:</p> <ul> <li><code>Query</code>: handles the query string of the URL.</li> <li><code>Path</code>: handles the path of the URL.</li> <li><code>Fragment</code>: handles the fragment of the URL</li> <li><code>Netloc</code>: handles the netloc of the URL</li> </ul>"},{"location":"usage/url/#examples","title":"Examples","text":"<p>Here are some examples of how you can use the URL class:</p> <pre><code># Create a new URL\nurl = URL(\"https://www.example.com/path?key=value#fragment\")\n# Add a new query parameter\nurl.add(query={\"new_key\": \"new_value\"})\n# Set a new path\nurl.set(path=\"/new_path\")\n# Get the encoded string representation of the URL\nprint(url.encode()) # \"https://www.example.com/new_path?key=value&amp;new_key=new_value#fragment\"\n# Create a new URL\nurl = URL(\"https://www.example.com/path?key=value#fragment\")\n# Add a new netloc\nurl.add(\nnetloc_obj=Netloc(\nusername=\"user\",\nhost=\"host\", \nport=5432,\n), \nscheme=\"postgresql\"\n)\n# Change the fragment\nurl.set(fragment='another')\n# Get the resolved string representation\nprint(url.encode()) # \"postgresql://user@host:5432/path?key=value#another\"\n</code></pre>"},{"location":"usage/utils/","title":"Utils","text":"<p>Utils is a module with a lot of functions and classes for diverse use cases and does not depend on any libraries or gyver features.</p>"},{"location":"usage/utils/#exceptions","title":"Exceptions","text":"<p>gyver.utils.exc has a single function:</p> <ul> <li><code>def panic(exc: type[ExceptionT], message: str, *args) -&gt; ExceptionT</code>:    <code>panic</code> instantiates the <code>exc</code> class with <code>message</code> and as its first parameter with an exclamation mark appended to it and the rest of the <code>*args</code>. If <code>message</code> already endswith an exclamation mark, panic will overwrite it.</li> </ul> <pre><code>from gyver.utils import panic\n# raises IndexError with first arg as \"Index should be 1!\"\nraise panic(IndexError, \"Index should be 1\")\n</code></pre>"},{"location":"usage/utils/#finder","title":"Finder","text":"<p>gyver.utils.finder provides an interface to search for and import specific entities (defined by a user-provided validator function) from a codebase. This can be useful if you need to load dynamically entities into the namespace, for example, in a migration script.</p> <p>By default, Gyver ships with two validators:</p> <ul> <li><code>instance_validator(*types: type)</code>: When used with <code>Finder</code>, this selects entities that are instances of any of the <code>types</code> provided.</li> <li><code>class_validator(*types: type)</code>: When used with <code>Finder</code>, this selects entities that inherit from any of the <code>types</code> provided. The <code>class_validator</code> excludes the parent class itself from the match.</li> </ul>"},{"location":"usage/utils/#example","title":"Example:","text":"<pre><code>from gyver.utils import FinderBuilder\nfrom pathlib import Path\nMY_ROOT_DIR = Path(__file__).parent\nclass MyClass:\ndef __init__(self):\nself.value = 1\n# Create a Finder instance using instance_validator, passing\n# your desired class(es) as its parameter and the root dir.\n# Your root dir will be used to import. For example: my_root_dir.mymod.myclass_instance\nfinder = (\nFinderBuilder()\n.instance_of(MyClass)\n.from_path(MY_ROOT_DIR)\n.build()\n)\n# Run finder.find() to search for the instances.\n# After this step, your instances are already loaded in the namespace.\noutput = finder.find()\n# If you actually need to handle the output,\n# the output mapping is [modname: str, instance: instance_object],\n# which can be used to access the loaded entities and their __module__.\nfor modname, instance in output.items():\nprint(modname, instance)\n</code></pre>"},{"location":"usage/utils/#json","title":"JSON","text":"<p>gyver.utils.json is a wrapper around orjson to make dumps return as string instead of bytes. Has a similar interface to most json libraries.</p> <pre><code>from gyver.utils import json\nval = json.loads('{\"hello\": \"world\"}')\nval == json.dumps({\"hello\": \"world\"})\nwith open(\"myfile.json\", \"w\") as stream:\njson.dump(val, stream)\nwith open(\"myfile.json\") as stream:\nval = json.load(stream)\n</code></pre>"},{"location":"usage/utils/#strings","title":"Strings","text":"<p>gyver.utils.strings has functions to parse some string formats.</p> <ul> <li><code>def to_snake(camel_string: str) -&gt; str</code>: changes any string to <code>snake_case</code></li> <li><code>def to_camel(snake_string: str) -&gt; str</code>: changes any string to <code>camelCase</code></li> <li><code>def to_pascal(snake_string: str) -&gt; str</code>: changes any string to <code>PascalCase</code></li> <li><code>def to_lower_kebab(anystring: str) -&gt; str</code>: changes any string to <code>kebab-case</code></li> <li><code>def make_lex_separator(outer_cast: type[list | tuple | set], cast: type = str) -&gt; Callable[[str], type[list | tuple | set]]</code>: makes a function that parses comma separated strings into the expected value with the shlex module</li> </ul>"},{"location":"usage/utils/#using-lex-separator","title":"Using lex separator","text":"<pre><code>from enum import Enum\nfrom gyver.utils.strings import make_lex_separator\nstring1 = 'hello, world'\nstring2 = 'foo, bar, baz'\nstring3 = '1, 2, 3'\nclass MyEnum(Enum):\nFOO = 'foo'\nBAR = 'bar'\nBAZ = 'baz'\n# here the parser will parse each item as a str\n# and return them in a list\nstring1_parser = make_lex_separator(list, str)\nstring1_parsed = string1_parser(string1) # [\"Hello\", \"world\"]\n# in the second case, the parser returns a set of enums\nstring2_parser = make_lex_separator(set, MyEnum)\nstring2_parsed = string2_parser(string2) # {MyEnum.FOO, MyEnum.BAR, MyEnum.BAZ}\n# in the third case, the parser will return a tuple of ints\nstring3_parser = make_lex_separator(tuple, int)\nstring3_parsed = string3_parser(string3) # (1, 2, 3)\n</code></pre>"},{"location":"usage/utils/#lazy","title":"Lazy","text":"<p>gyver.utils.lazy has utilities to allow for lazily defined attributes so that you can avoid some patterns like the one below or avoid calculating a property twice.</p> <pre><code>class MyClass:\ndef __init__(self):\nself._val = None\ndef get_val(self):\nif val is None:\nself._do_something()\nreturn self._val\n</code></pre>"},{"location":"usage/utils/#lazyfield","title":"lazyfield","text":"<p>The lazyfield descriptor streamlines the process of implementing lazy attributes. Here's how you can use it:</p> <pre><code>from gyver.utils import lazyfield\nclass MyClass:\n@lazyfield\ndef expensive_value(self):\nreturn do_expensive_operation()\ninstance = MyClass()\ninstance.expensive_value # Does the expensive operation, saves the result and returns the value\ninstance.expensive_value # Returns directly the cached value\ndel instance.expensive_value # Cleans the cache\ninstance.expensive_value # redo the expensive operation\ninstance.expensive_value = \"Other\" # Overwrites the cached value with the value assigned\n</code></pre> <p>Info</p> <p><code>lazyfield</code> saves the value directly in the class as a hidden attribute so you don't have to worry about garbage collection or weakrefs</p>"},{"location":"usage/utils/#asynclazyfield","title":"asynclazyfield","text":"<p>The asynclazyfield descriptor tackles the same issue as lazyfield, but while preserving the asynchronous API</p> <pre><code>from gyver.utils import asynclazyfield\nclass MyClass:\n@asynclazyfield\nasync def expensive_value(self):\nreturn await do_expensive_operation()\ninstance = MyClass()\nawait instance.expensive_value() # you still call it as a function, but it will do the same thing, call the function, store the result and return the value\nawait instance.expensive_value() # now it only returns the value\ndellazy(instance, \"expensive_value\") # clear the stored value\nawait instance.expensive_value() # here the calculation is done again\nsetlazy(instance, \"expensive_value\", \"Other\") # overwrite the stored value with \"Other\"\n</code></pre> <p>Info</p> <p>the <code>asynclazyfield</code> does not support set and delete so there are helpers provided below to help with that</p>"},{"location":"usage/utils/#helpers","title":"Helpers","text":"<p><code>gyver.utils.lazy</code> provides helpers to work with frozen classes or when using the asynclazyfield and need to set or reset the field manually</p> <ul> <li><code>setlazy(instance: Any, attribute: str, value: Any, bypass_setattr: bool = False)</code> setlazy allows you to directly change the hidden attribute behind any lazy field, and the bypass_setattr parameter will instead of using the <code>setattr</code> function, use <code>object.__setattr__</code>.</li> <li><code>dellazy(instance: Any, attribute: str, bypass_delattr: bool = False)</code> dellazy allows you to clear the value stored in the hidden attribute to allow for recalculation. Similar to setlazy the bypass_delattr parameter will use <code>object.__delattr__</code> instead of <code>delattr</code></li> <li><code>force_set(instance: Any, attribute: str, value: Any)</code> force_set is just a shortcut for setlazy(..., bypass_setattr=True)</li> <li><code>force_del(instance: Any, attribute: str)</code> force_del is just a shortcut for dellazy(..., bypass_delattr=True)</li> <li><code>is_initialized(instance: Any, attribute: str)</code>  Returns whether the lazyfield has stored a value yet, without triggering the routine inadvertently.</li> </ul>"},{"location":"usage/utils/#helpers_1","title":"Helpers","text":"<p>The gyver.utils.helpers module provides several helper functions and classes that can assist you in various tasks. These helpers are designed to facilitate common operations and offer useful functionalities.</p> <ul> <li>cache function is a wrapper around <code>functools.cache</code> but with improved type hints</li> <li>deprecated decorator marks a function as deprecated and issues a warning when it's used. This is useful for indicating that a function is no longer recommended for use.</li> <li>DeprecatedClass class is used to mark a class as deprecated. Instantiating this class will issue a deprecation warning. This is helpful when transitioning from old to new class structures.</li> <li>merge_dicts function allows you to merge two dictionaries with customizable conflict resolution strategies. It's particularly useful when you need to combine dictionaries while handling potential conflicts.</li> </ul>"},{"location":"usage/utils/#timezone","title":"Timezone","text":"<p>The gyver.utils.timezone module provides functions to work with timezones and date-time related operations.</p> <ul> <li>now Get the current aware datetime.</li> <li>today Get today's aware date.</li> <li>make_now_factory Create a function to get the current aware datetime with a specific timezone.</li> </ul>"},{"location":"usage/context/","title":"Context","text":"<p>gyver.context is a utility designed to simplify the management of resource acquisition and sharing within various sections of code. This utility becomes particularly advantageous when dealing with resources that require specific enabling and disabling procedures, as well as ensuring proper handling of resource lifecycles. Consider the following use case:</p> <pre><code>class ExpensiveResource:\ndef enable_expensive_resource(self):\n# Code to enable the expensive resource\n...\ndef is_active(self) -&gt; bool:\n# Check if the expensive resource is currently active\n...\ndef disable_expensive_resource(self):\n# Code to disable the expensive resource\n...\ndef function_a():\nresource = ExpensiveResource()\nresource.enable_expensive_resource()\nvalue_a = function_b(resource)\nvalue_b = function_c(resource)\nvalue_c = function_d(resource)\nresource.disable_expensive_resource()\nreturn value_a, value_b, value_c\ndef function_b(resource: ExpensiveResource):\nresource_was_active = resource.is_active()\nif not resource.is_active():\nresource.enable_expensive_resource()\nvalue = do_something(resource)\nif not resource_was_active:\nresource.disable_expensive_resource()\nreturn value\n# Similar functions for function_c and function_d\n</code></pre> <p>Now, let's consider the same example with an improved approach using gyver.context:</p> <pre><code>from gyver.context import Context\n# First, define an adapter class that adheres to the Adapter interface\nclass ExpensiveResourceAdapter:\ndef is_closed(self, client: ExpensiveResource):\nreturn not client.is_active()\ndef release(self, client: ExpensiveResource):\nclient.disable_expensive_resource()\ndef new(self):\nclient = ExpensiveResource()\nclient.enable_expensive_resource()\nreturn client\n# Utilize the adapter with gyver.context as shown below\ndef function_a():\nexpensive_context = Context(ExpensiveResourceAdapter())\n# Within this context manager, Adapter.new is invoked,\n# and the resource is tracked until the context ends\nwith expensive_context:\nvalue_a = function_b(expensive_context)\nvalue_b = function_c(expensive_context)\nvalue_c = function_d(expensive_context)\n# Upon context exit, context calls Adapter.release(resource)\nreturn value_a, value_b, value_c\n# In function_b, the resource status check is no longer required.\n# The resource is managed seamlessly within the context.\ndef function_b(context: Context[ExpensiveResource]):\n# The context manager handles resource initialization,\n# reuse, and cleanup automatically\nwith context as resource:\nreturn do_something(resource)\n</code></pre> <p>By employing gyver.context, you streamline the management of resource acquisition and ensure proper resource handling throughout the code, resulting in cleaner, more concise, and more maintainable code.</p>"},{"location":"usage/context/adapter/","title":"The Adapter Interface","text":"<p>gyver.context provides four adapter interfaces, each catering to different paradigms as required.</p>"},{"location":"usage/context/adapter/#adapter","title":"Adapter","text":"<p>Asyncio</p> <p>In an asyncio context, you can use the AsyncAdapter instead, which requires the same methods but in an <code>async def</code> version.</p> <p>The Adapter interface serves as a foundation for managing simple synchronous resources. It defines the following required methods:</p> <ul> <li>is_closed: This method checks the status of the resource. In cases where certain resources lack an explicit API for checking openness, returning <code>False</code> is acceptable.</li> <li>new: Acquires a new resource. It should create a new resource and return it using synchronous programming paradigms.</li> <li>release: Releases a resource.</li> </ul>"},{"location":"usage/context/adapter/#atomicadapter","title":"AtomicAdapter","text":"<p>Asyncio and Adapter</p> <p>Both AtomicAdapter and AtomicAsyncAdapter share the same interface, with <code>async def</code> versions for AtomicAsyncAdapter's methods. Furthermore, AtomicAdapter and AtomicAsyncAdapter inherit from their respective Adapter counterparts, requiring compliance with both interfaces.</p> <p>The AtomicAdapter interface extends the Adapter interface to include support for synchronous resource management with atomicity. It encompasses methods for managing atomic operations and their outcomes:</p> <ul> <li>begin: Initializes an atomic operation.</li> <li>commit: Commits the current atomic operation.</li> <li>rollback: Rolls back the current atomic operation.</li> <li>in_atomic: Indicates whether the current resource is involved in an atomic operation.</li> </ul>"},{"location":"usage/context/adapter/#sync-example","title":"Sync Example","text":""},{"location":"usage/context/adapter/#adapter_1","title":"Adapter","text":"<p>In this example, we'll demonstrate how to create a synchronous adapter using the <code>gyver.context</code> module. This adapter manages a requests session, highlighting the process of acquiring and releasing resources within a context.</p> <pre><code>import requests\nfrom gyver.context import Context\nclass SessionAdapter:\ndef new(self):\n\"\"\"\n        Create a new requests session.\n        \"\"\"\nreturn requests.Session()\ndef release(self, client: requests.Session):\n\"\"\"\n        Release the requests session by closing it.\n        \"\"\"\nclient.close()\ndef is_closed(self, client: requests.Session) -&gt; bool:\n\"\"\"\n        Check if the requests session is closed.\n        Since requests does not have an explicit way to check session status,\n        we assume it's never closed and return False.\n        \"\"\"\nreturn False\n# Create a context using the SessionAdapter\nsession_context = Context(SessionAdapter())\n</code></pre>"},{"location":"usage/context/adapter/#atomicadapter_1","title":"AtomicAdapter","text":"<p>In this example, we'll illustrate how to implement an atomic adapter using the <code>gyver.context</code> module. This adapter integrates with SQLAlchemy to manage database connections within a transactional context.</p> <pre><code>import typing\nimport sqlalchemy as sa\nimport sqlalchemy.engine as sa_engine\nfrom gyver import context\nfrom gyver.utils import lazyfield\nSaContext = context.Context[sa_engine.Connection]\nclass SaAdapter(context.Adapter[sa_engine.Connection]):\n\"\"\"\n    A synchronous adapter for managing SQLAlchemy connections within a transactional context.\n    \"\"\"\n@typing.overload\ndef __init__(\nself,\n*,\nuri: str,\nengine: None = None,\n) -&gt; None:\n...\n@typing.overload\ndef __init__(\nself,\n*,\nuri: None = None,\nengine: sa_engine.Engine,\n) -&gt; None:\n...\ndef __init__(\nself,\n*,\nuri: typing.Optional[str] = None,\nengine: typing.Optional[sa_engine.Engine] = None,\n) -&gt; None:\nif not any((uri, engine)):\nraise TypeError(\"Missing parameters (uri/engine)\")\nself._uri = uri\nif engine is not None:\nself._engine = engine\n@lazyfield\ndef _engine(self):\nassert self._uri\nreturn sa.create_engine(self._uri)\ndef is_closed(self, client: sa_engine.Connection) -&gt; bool:\n\"\"\"\n        Check if the database connection is closed.\n        \"\"\"\nreturn client.closed\ndef new(self):\n\"\"\"\n        Create a new database connection.\n        \"\"\"\nreturn self._engine.connect()\ndef release(self, client: sa_engine.Connection) -&gt; None:\n\"\"\"\n        Release the database connection.\n        \"\"\"\nclient.close()\ndef begin(self, client: sa_engine.Connection) -&gt; None:\n\"\"\"\n        Begin a transaction.\n        \"\"\"\nif client.in_transaction():\nclient.begin_nested()\nelse:\nclient.begin()\ndef commit(self, client: sa_engine.Connection) -&gt; None:\n\"\"\"\n        Commit the transaction.\n        \"\"\"\nif trx := (client.get_nested_transaction() or client.get_transaction()):\ntrx.commit()\ndef rollback(self, client: sa_engine.Connection) -&gt; None:\n\"\"\"\n        Roll back the transaction.\n        \"\"\"\nif trx := (client.get_nested_transaction() or client.get_transaction()):\ntrx.rollback()\ndef in_atomic(self, client: sa_engine.Connection) -&gt; bool:\n\"\"\"\n        Check if the connection is within an active transaction.\n        \"\"\"\nreturn client.in_transaction()\ndef context(\nself,\n) -&gt; \"SaContext\":\n\"\"\"\n        Create a context using the adapter.\n        \"\"\"\nreturn SaContext(self)\n</code></pre>"},{"location":"usage/context/adapter/#async-example","title":"Async Example","text":""},{"location":"usage/context/adapter/#asyncadapter","title":"AsyncAdapter","text":"<p>In this example, we'll showcase the implementation of an asynchronous adapter using the <code>gyver.context</code> module. The adapter manages asynchronous resources, specifically <code>aiohttp</code> client sessions, demonstrating how to acquire and release these resources within an asynchronous context.</p> <pre><code>import aiohttp\nfrom gyver.context import AsyncContext\nclass AsyncSessionAdapter:\nasync def new(self):\n\"\"\"\n        Create a new aiohttp client session asynchronously.\n        \"\"\"\nreturn aiohttp.ClientSession()\nasync def release(self, client: aiohttp.ClientSession):\n\"\"\"\n        Release the aiohttp client session asynchronously by closing it.\n        \"\"\"\nawait client.close()\nasync def is_closed(self, client: aiohttp.ClientSession):\n\"\"\"\n        Check if the aiohttp client session is closed asynchronously.\n        \"\"\"\nreturn client.closed\n# Create an asynchronous context using the AsyncSessionAdapter\nasync_session_context = AsyncContext(AsyncSessionAdapter())\n</code></pre>"},{"location":"usage/context/adapter/#atomicasyncadapter","title":"AtomicAsyncAdapter","text":"<p>In this example, we'll demonstrate the implementation of an <code>AtomicAsyncAdapter</code> using SQLAlchemy's asynchronous features. This adapter allows you to manage asynchronous database connections and transactions seamlessly using the <code>gyver.context</code> module.</p> <pre><code>import typing\nimport sqlalchemy.ext.asyncio as sa_asyncio\nfrom gyver import context\nfrom gyver.utils import lazyfield\nAsyncSaContext = context.AsyncContext[sa_asyncio.AsyncConnection]\nclass AsyncConnectionAdapter(context.AtomicAsyncAdapter[sa_asyncio.AsyncConnection]):    \n\"\"\"\n    An atomic asynchronous adapter for managing SQLAlchemy connections and transactions.\n    \"\"\"\n@typing.overload\ndef __init__(\nself,\n*,\nuri: str,\nengine: None = None,\n) -&gt; None:\n...\n@typing.overload\ndef __init__(\nself,\n*,\nuri: None = None,\nengine: sa_asyncio.AsyncEngine,\n) -&gt; None:\n...\ndef __init__(\nself,\n*,\nuri: typing.Optional[str] = None,\nengine: typing.Optional[sa_asyncio.AsyncEngine] = None,\n) -&gt; None:\nif not any((uri, engine)):\nraise TypeError(\"Missing parameters (uri/engine)\")\nself._uri = uri\nif engine is not None:\nself._engine = engine\n@lazyfield\ndef _engine(self):\nassert self._uri\nreturn sa_asyncio.create_async_engine(self._uri)\ndef _create_connection(self):\nreturn self._engine.connect()\nasync def is_closed(self, client: sa_asyncio.AsyncConnection) -&gt; bool:\n\"\"\"\n        Check if the asynchronous database connection is closed.\n        \"\"\"\nreturn client.closed\nasync def release(self, client: sa_asyncio.AsyncConnection) -&gt; None:\n\"\"\"\n        Release the asynchronous database connection.\n        \"\"\"\nreturn await client.close()\nasync def new(self) -&gt; sa_asyncio.AsyncConnection:\n\"\"\"\n        Create a new asynchronous database connection.\n        \"\"\"\nreturn await self._create_connection()\nasync def begin(self, client: sa_asyncio.AsyncConnection) -&gt; None:\n\"\"\"\n        Begin an asynchronous transaction.\n        \"\"\"\nif client.in_transaction():\nawait client.begin_nested()\nelse:\nawait client.begin()\nasync def commit(self, client: sa_asyncio.AsyncConnection) -&gt; None:\n\"\"\"\n        Commit the asynchronous transaction.\n        \"\"\"\nif trx := (client.get_nested_transaction() or client.get_transaction()):\nawait trx.commit()\nasync def rollback(self, client: sa_asyncio.AsyncConnection) -&gt; None:\n\"\"\"\n        Roll back the asynchronous transaction.\n        \"\"\"\nif trx := (client.get_nested_transaction() or client.get_transaction()):\nawait trx.rollback()\nasync def in_atomic(self, client: sa_asyncio.AsyncConnection) -&gt; bool:\n\"\"\"\n        Check if the asynchronous connection is within an active transaction.\n        \"\"\"\nreturn client.in_transaction()\ndef context(\nself,\n) -&gt; AsyncSaContext:\n\"\"\"\n        Create a context using the adapter.\n        \"\"\"\nreturn AsyncSaContext(self)\n# Create an asynchronous context using the AsyncConnectionAdapter\nasync_sa_context = AsyncSaContext(AsyncConnectionAdapter())\n</code></pre> <p>In these examples, we demonstrate how to create different types of adapters and contexts using the gyver.context module for both synchronous and asynchronous resource management. This approach allows for efficient and flexible resource handling in various programming paradigms.</p>"},{"location":"usage/context/atomic/","title":"Atomicity","text":"<p>When working with the atomic interface provided by gyver.context, you can take advantage of the atomic utility function. This function simplifies the creation of atomic contexts in both synchronous and asynchronous scenarios.</p>"},{"location":"usage/context/atomic/#using-the-atomic-utility-function","title":"Using the <code>atomic</code> Utility Function","text":"<p>Asyncio</p> <p>Note that the <code>atomic</code> function also works for the AtomicAsyncAdapter</p> <p>The atomic utility function allows you to create atomic contexts with ease. It wraps a given context with the atomic interface, ensuring proper resource management and atomic operations.</p> <p>Example:</p> <pre><code>from gyver.context import atomic\n# Create an atomic context using the atomic utility function\natomic_context = atomic(my_context)\n# Inside the atomic context, the atomicity is managed automatically\nwith atomic_context as resource:\n# Perform operations within the atomic context\ndo_something()\n# Upon exiting the atomic context, the adapter's `rollback` or `commit` methods are invoked\n# if any errors occurred. This happens only at the outermost frame.\n</code></pre> <p>The <code>atomic</code> function also supports an optional parameter <code>bound</code>, which determines whether the resulting context will be the owner of the resource or will attach to the current context. By default, <code>bound</code> is set to <code>True</code>, allowing reuse of already active resources from the provided context. It handles all context management from that context. When set to <code>False</code>, the new context manages resources independently, opening and closing them based on its own stack count.</p> <p>Example:</p> <pre><code># Assume there's an active resource from the outer context\nclient = None\n# Wrapping an existing context with the atomic interface\nwith context as client:\npass\n# Creating an atomic context that reuses the existing resource (bound=True)\nwith atomic(context) as atomic_client:\nprint(atomic_client is client)  # True\n# Creating an independent atomic context with its own resource (bound=False)\nwith atomic(context, bound=False) as unbound_client:\nprint(unbound_client is client)  # False\n</code></pre>"},{"location":"usage/database/","title":"Working with Database","text":"<p>Gyver provides tools that streamline the process of working with databases, reducing the boilerplate required for database interactions.</p>"},{"location":"usage/database/#example-simplified-database-interaction","title":"Example: Simplified Database Interaction","text":"<p>Here's an example that demonstrates how to use Gyver's database module to interact with a database using SQLAlchemy:</p> <pre><code>from gyver.database import DatabaseAdapter, DatabaseConfig, Driver\nimport sqlalchemy as sa\n# Create a DatabaseAdapter to load necessary configurations from the environment\n# The DatabaseConfig class is annotated with `@as_config`, and DatabaseAdapter\n# calls it using `AdapterConfigFactory().maker(DatabaseConfig, \"db\")`.\n# Therefore, make sure your environment variables are prefixed with DB_&lt;ATTRIBUTE&gt;.\nprovider = DatabaseAdapter()\n# Alternatively, you can configure the adapter manually\n# If you set the port to -1 or leave it unset, the default port for the specified\n# driver (in this case, 3306 for MySQL) will be used.\nadapter = DatabaseAdapter(DatabaseConfig(\ndriver=Driver.MYSQL,\nhost=\"myhost\",\nport=3306,\nuser=\"myuser\",\npassword=\"mypassword\"\nname=\"mydb\",\npool_size=10,\npool_recycle=3600,\nmax_overflow=0,\nautotransaction=False,\n))\n# Obtain the appropriate context for your desired SQLAlchemy component\ncontext = adapter.context()        # for sqlalchemy's Connection\n# context = adapter.session()       # for sqlalchemy's Session\n# context = adapter.async_context() # for sqlalchemy's AsyncConnection\n# context = adapter.async_session() # for sqlalchemy's AsyncSession\n# Open a connection using the obtained context\nwith context as connection:\n# Run your SQLAlchemy code\nresult = connection.execute(sa.select(sa.text(\"'Hello World'\")))\n# If you're using the asyncio interface\nasync with context as connection:\nresult = await connection.execute(sa.select(sa.text(\"'Hello World'\")))\n</code></pre> <p>The Gyver database module simplifies the process of establishing and managing database connections, enabling you to focus on writing database interactions without getting bogged down by intricate setup and teardown procedures. It's designed to enhance productivity and readability when working with databases in your Python projects.</p>"},{"location":"usage/database/adapter/","title":"Adapter and Contexts","text":"<p>Gyver provides a robust configuration class and adapter system that offers extensive support for various environments, facilitating seamless integration with different resources.</p>"},{"location":"usage/database/adapter/#databaseconfig","title":"DatabaseConfig","text":"<p>DatabaseConfig is decorated with as_config and encompasses the following configurable parameters:</p> <ul> <li>driver: Driver, an enumeration with the options:<ul> <li><code>.MYSQL</code></li> <li><code>.POSTGRES</code></li> <li><code>.SQLITE</code></li> <li><code>.MARIADB</code></li> <li><code>.CUSTOM</code></li> </ul> </li> <li>host: <code>str</code>, The database host; for SQLite databases, provide the filepath.</li> <li>port: <code>int</code>, The database port; if not specified or set to -1, the default port for the chosen driver is used.</li> <li>user: <code>str</code>, The user for connecting to the database. (Optional)</li> <li>password: <code>str</code>, The password for connecting to the database. (Optional)</li> <li>name: <code>str</code>, The name for connecting to the database. (Optional, only for non-SQLite drivers)</li> <li>pool_size: <code>int</code>, the size of the connection pool to be used; the default is 20.</li> <li>pool_recycle: <code>int</code>, time in seconds before recycling a connection; the default is 3600.</li> <li>max_overflow: <code>int</code>, The maximum connections if the pool is full; the default is 0.</li> </ul> <p>Regarding Dialect Defaults and Customization</p> <p>To check dialect default values, refer to the source code of resolve_driver. To access the resolved port of the configuration, use database_config.effective_port.</p> <p>If you need a dialect implementation other than those provided by Gyver:   - Ensure SQLAlchemy supports the dialect.   - Create a class adhering to the Dialect protocol or create an instance of DialectInfo with the desired defaults..   - Use <code>Driver.CUSTOM</code> in the <code>.driver</code> attribute of the configuration.   - Prior to using <code>db_config</code>, call <code>db_config.override_dialect(your_dialect_instance)</code>.</p>"},{"location":"usage/database/adapter/#usage","title":"Usage","text":"<pre><code>from gyver.config import AdapterConfigFactory, DialectInfo\nfrom gyver.database.config import DatabaseConfig\n# In this case, the expected environment variables will include:\n# DB_DRIVER (options: 'mysql', 'postgres', 'sqlite', 'mariadb', 'custom')\n# DB_HOST (database host without the schema)\n# DB_PORT (port as an integer) (Optional)\n# DB_USER (database username) (Optional; Gyver will URL-encode the username)\n# DB_PASSWORD (database password) (Optional; Gyver will URL-encode the password)\n# DB_NAME (database name) (Optional; Gyver will URL-encode the name)\n# DB_POOL_SIZE (pool size as an integer) (Optional)\n# DB_POOL_RECYCLE (pool recycle as an integer) (Optional)\n# DB_MAX_OVERFLOW (max overflow as an integer) (Optional)\nconfig = AdapterConfigFactory().load(DatabaseConfig, __prefix__=\"db\")\n# To override the dialect implementation:\n# 1. Verify if SQLAlchemy supports the desired dialect.\n# 2. Create a class representing the dialect adhering to the Dialect protocol or create an instance of DialectInfo with the desired values.\n# 3. Pass an instance of the dialect to the config.\nclass AioPGDialect:\ndefault_port = 5432\ndriver = Driver.POSTGRES\ndialect_name = \"postgresql\"\nasync_driver = \"aiopg\"\nsync_driver = \"psycopg2\"\nonly_host = False\n# Alternatively, create an instance of DialectInfo\naio_pg_dialect = DialectInfo(\ndefault_port=5432,\ndriver=Driver.POSTGRES,\ndialect_name=\"postgresql\",\nasync_driver=\"aiopg\",\nsync_driver=\"psycopg2\",\nonly_host=False,\n)\nconfig.override_dialect(AioPGDialect())\n</code></pre>"},{"location":"usage/database/adapter/#the-adapter","title":"The Adapter","text":"<p>Gyver provides an adapter for integration with SQLAlchemy, featuring a flexible interface already integrated with gyver.context.</p> <p>Warning</p> <p>The Session context handler for both sync and asyncio interfaces internally employs an SQLAlchemy Connection, limiting session accessibility outside the context.</p>"},{"location":"usage/database/adapter/#sync-interface","title":"Sync Interface","text":"<p>When working with a synchronous interface, you can utilize the adapter to perform various tasks.</p> <p>Example:</p> <pre><code>from gyver.database import DatabaseAdapter\n# Create a new adapter instance\nadapter = DatabaseAdapter()\n# With the adapter at hand, you can create various \n# contexts for both the core and the\n# ORM API of SQLAlchemy.\n# adapter.context() returns a context handler \n# for the core API, utilizing \n# a sqlalchemy.engine.Connection as the resource.\nadapter.context()\n# adapter.session() returns a context handler \n# for the ORM API, utilizing a \n# sqlalchemy.orm.Session as the resource.\nadapter.session()\n# Should you need to directly use the \n# SQLAlchemy engine, access it \n# through adapter.engine.\nadapter.engine\n</code></pre>"},{"location":"usage/database/adapter/#the-asyncio-interface","title":"The Asyncio Interface","text":"<p>When working with an asyncio driver, you can still use the same adapter with asyncio methods.</p> <pre><code>from gyver.database import DatabaseAdapter\n# Create a new adapter instance\nadapter = DatabaseAdapter()\n# With the adapter at hand, you can create \n# various contexts for both the\n# core and the ORM API of SQLAlchemy.\n# adapter.async_context() returns a \n# context handler for the core API, utilizing a \n# sqlalchemy.ext.asyncio.AsyncConnection as the resource.\nadapter.async_context()\n# adapter.async_session() returns a \n# context handler for the ORM API, utilizing a\n# sqlalchemy.ext.asyncio.AsyncSession as the resource.\nadapter.async_session()\n# Should you need to directly use the \n# SQLAlchemy engine, access it through \n# adapter.async_engine.\nadapter.async_engine\n</code></pre> <p>Warning</p> <p>By default, all database helper classes are frozen. To modify the configuration, create a new adapter instance.</p>"},{"location":"usage/database/query/","title":"SQLAlchemy Queries helper","text":"<p>Gyver provides query helpers to address the following challenges:</p> <ul> <li>When you want to avoid scattering your ORM classes throughout your code.</li> <li>When you need a generic repository function for running queries.</li> </ul>"},{"location":"usage/database/query/#example","title":"Example","text":"<p>Let's consider a generic function for running a SELECT query on specific fields of the Person entity.</p> <pre><code>from gyver.database import Entity\nfrom gyver.database.sqlalchemy import SaContext\nimport sqlalchemy as sa\nclass Address(Entity):\nstreet = sa.Column(sa.Text)\nnumber = sa.Column(sa.Integer)\ncountry = sa.Column(sa.Text)\nzip_code = sa.Column(sa.Text)\nclass Person(Entity):\nname = sa.Column(sa.String(100))\nemail = sa.Column(sa.Text)\naddress_id = sa.Column(sa.Integer, sa.ForeignKey('address.id'))\naddress = make_relation(Address, use_list=True)\n</code></pre> <p>Without Gyver's helpers, the function might look like this:</p> <pre><code>def list_people(context: SaContext, **comparison):\nq = sa.select(Person).where(\n*(\ngetattr(Person, field, getattr(Address, field)) == value \nfor field, value in comparison.items()\n)\n)\nwith context as connection:\nresult = connection.execute(q)\n# Then, call the function\nlist_people(context, name='anyname', zipcode=\"012345678\")\n</code></pre> <p>With Gyver, you can achieve a more powerful approach:</p> <pre><code>from gyver.database import query\ndef list_people(context: SaContext, where: query.BindClause):\nq = sa.select(Person).where(where.bind(Person))\nwith context as connection:\nresult = connection.execute(q)\nlist_people(\ncontext, \nquery.and_(\n# Access the 'name' attribute directly on the person\nquery.Where('name', 'anyname'), \n# Access the 'zipcode' attribute on address; no conflict between Person and Address names\nquery.Where('address.zipcode', \"012345678\"),\n# You can use comparisons other than equals\nquery.Where('address.number', 3, query.comp.greater)\n)\n)\n</code></pre>"},{"location":"usage/database/query/#clauses","title":"Clauses","text":"<p>Query helpers from gyver adhere to the Clause interface, either from:</p> <ul> <li><code>BindClause</code>, or</li> <li><code>ApplyClause</code></li> </ul>"},{"location":"usage/database/query/#bindclause","title":"BindClause","text":"<p>BindClauses are clauses that include the <code>.bind(mapper) -&gt; query.Comparison</code> method. They expect an entity class, a table instance, or a ColumnCollection from SQLAlchemy. The comparison interface is designed for a SQLAlchemy ORM comparison or a boolean column.</p> <p>The BindClauses are:</p> <ul> <li><code>query.Where(field: str, expected: T, comp: query.Comparator[T])</code></li> <li><code>query.and_(*where: query.BindClause)</code></li> <li><code>query.or_(*where: query.BindClause)</code></li> <li><code>query.AlwaysTrue()</code></li> <li><code>query.RawQuery(cmp: query.Comparison)</code></li> </ul>"},{"location":"usage/database/query/#apply-clause","title":"Apply Clause","text":"<p>ApplyClauses are clauses that utilize the <code>.apply(query: sa.sql.Select) -&gt; sa.sqlSelect</code> method. They expect a <code>Select</code> query instance and return another <code>Select</code> query instance.</p> <p>The ApplyClauses are:</p> <ul> <li><code>query.Paginate(limit: int, offset: int)</code></li> <li><code>query.OrderBy(field: typing.Optional[str], direction: OrderDirection)</code></li> </ul>"},{"location":"usage/database/query/#where","title":"Where","text":"<p>The <code>Where</code> class represents a comparison between a table and an expected value. It has the following parameters:</p> <ul> <li><code>field: str</code>: the field on the entity</li> <li><code>expected: T</code>: the expected value</li> <li><code>comp: query.Comparator[T]</code>: A callable that processes the comparison between the field and the expected value.</li> </ul>"},{"location":"usage/database/query/#comparators","title":"Comparators","text":"<p>The Comparator[T] protocol is defined as follows:</p> <pre><code>class Comparator(Protocol[T]):\ndef __call__(self, field: ColumnElement | sa.Column, target: T) -&gt; typing.Any:\n...\n# valid comparators\n# the equals comparator can accept any datatype\ndef equals(field: ColumnElement | sa.Column, target: Any) -&gt; Any:\nreturn field == target\nclass MyComparator:\ndef __init__(self, parser):\nself.parser = parser\n# MyComparator should only handle float values\n# This is annotated on the Where class\ndef __call__(field: ColumnElement | sa.Column, target: float) -&gt; Any:\nreturn self.parser(field) == target\n</code></pre> <p>The <code>Where</code> class is dependent on a comparator and gyver ships with a lot of defaults:</p> <ul> <li><code>always_true(field: FieldType, target: typing.Any)</code>: returns always a <code>sa.true()</code></li> <li><code>equals(field: FieldType, target: typing.Any)</code>: equivalent to <code>field == target</code></li> <li><code>not_equals(field: FieldType, target: typing.Any)</code>: equivalent to <code>field != target</code></li> <li><code>greater(field: FieldType, target: Sortable)</code>: equivalent to <code>field &gt; target</code><ul> <li>Sortable represents int, float, date, and time instances</li> </ul> </li> <li><code>greater_equals(field: FieldType, target: Sortable)</code>: equivalent to <code>field &gt;= target</code></li> <li>lesser(field: FieldType, target: Sortable): equivalent to <code>field &lt; target</code></li> <li><code>lesser_equals(field: FieldType, target: Sortable)</code>: equivalent to <code>field &lt;= target</code></li> <li><code>between(field: FieldType, target: tuple[Sortable, Sortable])</code> equivalent to <code>target[0] &lt;= field &lt;= target[1]</code></li> <li><code>range(field: FieldType, target: tuple[Sortable, Sortable])</code>: equivalent to <code>target[0] &lt;= field &lt; target[1]</code></li> <li><code>like(field: FieldType, target: str)</code>: equivalent to <code>FIELD LIKE '%{target}%'</code></li> <li><code>rlike(field: FieldType, target: str)</code>: equivalent to <code>FIELD LIKE '{target}%'</code></li> <li><code>llike(field: FieldType, target: str)</code>: equivalent to <code>FIELD LIKE '%{target}'</code></li> <li><code>insensitive_like(opt: typing.Literal[\"like\", \"rlike\", \"llike\"] = \"like\")</code>: equivalent to the like options but as insensitive<ul> <li><code>insensitive_like</code> returns a comparator so it must be called instead of passed as parameter. Eg.: <pre><code>query.Where('field', expected, query.comp.insensitive_like('rlike'))\n</code></pre></li> </ul> </li> <li><code>isnull(field: FieldType, target: bool)</code>: equivalent to <code>field is None if target else field is not None</code></li> <li><code>includes(field: FieldType, target: typing.Sequence)</code>: equivalent to <code>field in target</code></li> <li><code>excludes(field: FieldType, target: typing.Sequence)</code>: equivalent to <code>field not in target</code></li> <li><code>json_contains(field: FieldType, target: typing.Any)</code>: equivalent to <code>json_contains(field, '\"target\"')</code> (only mysql) (prefer normalizing table)</li> <li><code>json_empty(field: FieldType, target: typing.Any)</code>: equivalent to <code>json_length(field) == 0 if target else json_length(field != 0</code></li> <li><code>make_relation_check(clause: BindClause)</code>: returns a relationship check (if exists) based on the clause.<ul> <li>Ex: <pre><code># This will do a query where\nquery.Where(\n# if exists any address\n'address', \nTrue, \n# which\nmake_relation_check(\nquery.Where(\n# has an address number\n'address.number', \n1, \n# greater than 1\nquery.comp.greater\n)\n)\n)\n</code></pre></li> </ul> </li> <li><code>relation_exists(field: FieldType, target: bool)</code>: a relationship_check that checks only if exists</li> </ul>"},{"location":"usage/database/query/#usage","title":"Usage","text":"<ul> <li>All people with the name starting with G</li> </ul> <pre><code>query.Where('name', 'G', query.comp.rlike).bind(Person)\n</code></pre> <ul> <li>People with the name ending with s that have a gmail</li> </ul> <pre><code>query.and_(\nquery.Where('name', 's', query.comp.llike),\nquery.Where('email', 'gmail.com', query.comp.rlike)\n).bind(Person)\n</code></pre> <ul> <li>People with a given zipcode or with 'mayor' on the street name</li> </ul> <pre><code>query.or_(\nquery.Where('address.zipcode', '012345678'),\nquery.Where('address.street', 'mayor', query.comp.insensitive_like())\n).bind(Person)\n</code></pre> <ul> <li>People with no address registered or people with any address registered from rule above</li> </ul> <pre><code>query.or_(\nquery.Where('address', False, query.comp.relation_exists),\nquery.Where('address', True, query.comp.make_relation_check(\nquery.or_(\nquery.Where('address.zipcode', '012345678'),\nquery.Where('address.street', 'mayor', query.comp.insensitive_like())\n)\n)\n)\n).bind(Person)\n</code></pre>"},{"location":"usage/database/query/#paginate","title":"Paginate","text":"<p>Paginate implements the <code>ApplyClause</code> interface and provides a straightforward interface for paginating queries. It offers two implementations:</p>"},{"location":"usage/database/query/#limitoffsetpaginate","title":"LimitOffsetPaginate","text":"<p>This implementation performs the following operations:</p> <pre><code>```python\nq.limit(self.limit).offset(self.offset)\n```\n</code></pre>"},{"location":"usage/database/query/#fieldpaginate","title":"FieldPaginate","text":"<p>This implementation utilizes a specified field and comparison to perform pagination:</p> <pre><code>```python\nq.where(query.Where(self.field, self.offset, self.jump_comparison)).limit(self.limit)\n```\n</code></pre> <p>Both implementations have the same interface as Paginate.</p>"},{"location":"usage/database/query/#usage_1","title":"Usage","text":"<pre><code>q = sa.select(Person)\nq = query.LimitOffsetPaginate(limit=10, offset=3).apply(q)\n# or\nq = FieldPaginate(limit=10, offset=3).apply(q)\n</code></pre>"},{"location":"usage/database/query/#orderby","title":"OrderBy","text":"<p>Order by has a simple <code>ApplyClause</code> interface to order a query</p> <pre><code>    q = sa.select(Person)\nq = query.OrderBy.asc('address.number').apply(q)\n# or\nq = query.OrderBy.desc('id').apply(q)\n# or\nq = query.OrderBy.none().apply(q) # do nothing\n</code></pre>"},{"location":"usage/database/query/#helpers","title":"Helpers","text":"<p>There are also some helper functions to wrap comparisons on some specific cases</p> <ul> <li><code>query.as_date</code> will do date(field) == target</li> <li><code>query.as_lower</code> will do lower(field) == target</li> <li><code>query.as_time</code> will do time(field) == target</li> <li><code>query.as_upper</code> will do upper(field) == target</li> </ul>"},{"location":"usage/database/query/#usage_2","title":"Usage","text":"<pre><code>query.Where('field', expected, query.as_date(query.comp.equals))\n</code></pre>"},{"location":"usage/database/sqlalchemy/","title":"SQLAlchemy Defaults","text":"<p>Gyver offers default settings designed to expedite development with SQLAlchemy. These defaults include:</p> <ul> <li>gyver.database.default_metadata: A pre-configured sqlalchemy.MetaData object intended for use with Gyver defaults.</li> <li>Gyver's default entities and table factories</li> </ul>"},{"location":"usage/database/sqlalchemy/#entities","title":"Entities","text":"<p>In Gyver, entities refer to the ORM models that define your database structure. By default, Gyver provides two abstract classes:</p> <ul> <li>AbstractEntity: This abstract entity serves as the declarative base and automatically assigns the class name in lowercase as the default table name.</li> <li>Entity: Building on the abstract entity, the Entity class (also abstract) includes an integer primary key column named id that can be accessed through <code>.id_</code> or <code>.pk</code>.</li> </ul>"},{"location":"usage/database/sqlalchemy/#table-factories","title":"Table Factories","text":"<p>Gyver introduces two table factories to simplify your work:</p> <ul> <li>make_table: A wrapper around sa.Table creation, it is bound to the gyver.database.default_metadata. This offers streamlined table creation.</li> <li>create_relation_table: This helper aids in generating relation tables for many-to-many relationships. You can define the table name and related entities. The resulting table will have an integer primary key column and foreign key columns linking to the respective entities.</li> </ul>"},{"location":"usage/database/sqlalchemy/#alembic-and-migrations","title":"Alembic and migrations","text":"<p>For seamless integration with Alembic, follow these steps in your <code>env.py</code>:</p> <pre><code>from myproject import db_config, ROOT_DIR\nfrom gyver.database import make_uri, default_metadata, AbstractEntity\nfrom gyver.utils import FinderBuilder\nimport sqlalchemy as sa\n# ... Alembic code ...\n# Utilize the default metadata from Gyver\ntarget_metadata = default_metadata\n# Create finders to import all used tables and classes\n# This eliminates the need for individual imports\nFinderBuilder().instance_of(sa.Table).child_of(AbstractEntity).from_path(ROOT_DIR).find()\n# Create the URI using the configuration and sync mode\n# Alembic does not support asyncio drivers\ntarget_db_uri = make_uri(db_config, sync=True)\n# ... Alembic code ...\ndef run_migrations_offline() -&gt; None:\n# Use the created URI to run migrations\ncontext.configure(\nurl=target_db_uri,\ntarget_metadata=target_metadata,\nliteral_binds=True,\ndialect_opts={\"paramstyle\": \"named\"},\n)\nwith context.begin_transaction():\ncontext.run_migrations()\n# Use the same URI as in the run_migrations_offline\ncfg = config.get_section(config.config_ini_section)\ncfg[\"sqlalchemy.url\"] = target_db_uri  # type: ignore\nconnectable = engine_from_config(\ncfg,\nprefix=\"sqlalchemy.\",\npoolclass=pool.NullPool,\n)\nwith connectable.connect() as connection:\ncontext.configure(\nconnection=connection, target_metadata=target_metadata\n)\nwith context.begin_transaction():\ncontext.run_migrations()\n# ... Alembic code ...\n</code></pre>"}]}